{"version":3,"sources":["lib/nft.ts","lib/metadata.ts","Picker.tsx","Uploader.tsx","Minter.tsx","AlgorandWalletConnector.tsx","App.tsx","index.tsx","lib/ipfs.ts","lib/config.ts","lib/algorand.ts"],"names":["ARC3_URL_SUFFIX","METADATA_FILE","JSON_TYPE","ipfsURL","cid","resolveProtocol","activeConf","url","endsWith","slice","length","chunks","split","conf","ipfsGateway","Token","t","id","name","unitName","metadataHash","total","decimals","creator","manager","reserve","clawback","freeze","defaultFrozen","this","p","params","index","NFT","md","token","urlMimeType","metadata","Metadata","valid","image","substring","wallet","createToken","asset_id","fromAssetId","assetId","getToken","fromToken","fromParams","getMimeTypeFromIpfs","getMetaFromIpfs","omitRawAndEmpty","k","v","args","_raw","undefined","description","image_integrity","image_mimetype","background_color","external_url","external_url_integrity","external_url_mimetype","animation_url","animation_url_integrity","animation_url_mimetype","extra_metadata","localization","properties","Object","assign","fmt","hasOwnProperty","toString","hash","sha256","create","update","Uint8Array","digest","md_blob","Blob","type","File","JSON","stringify","parse","Picker","props","React","useState","options","setOptions","initialized","setInitialized","useEffect","listRecentFiles","activeConfig","then","opts","splice","md_promises","idx","opt","push","getIpfsUrlFromCID","Promise","all","arr","filtered","cards","map","option","DisplayCard","cidmd","className","elevation","Elevation","TWO","href","src","alt","Uploader","meta","setMeta","loading","setLoading","imgSrc","setImgSrc","fileObj","setFileObj","a","putToIPFS","window","location","reload","alert","UploadContainer","setFile","file","reader","FileReader","onload","e","target","result","readAsDataURL","size","intent","style","float","margin","onClick","large","disabled","text","onInputChange","event","stopPropagation","preventDefault","files","item","Minter","useParams","setMd","importingAccount","setImportingAccount","scanningAccount","setScanningAccount","nft","setNFT","sw","addr","xferAsset","acct","algosdk","generateAccount","fundAccount","NFTCard","mintOnly","mintAndCreate","AccountImporter","cancelCreate","continueCreate","AddressReader","optIn","handleScanned","THREE","isOpen","setIsOpen","mn","setMn","ic","secretKeyToMnemonic","sk","DIALOG_BODY","value","DIALOG_FOOTER","vref","useRef","scanner","setScanner","open","stop","start","seen","onOpened","current","QrScanner","data","width","ref","WORKER_PATH","AlgorandWalletConnector","selectorOpen","setSelectorOpen","sessionWallet","updateWallet","handleSelectedWallet","choice","currentTarget","allowedWallets","disconnect","SessionWallet","network","permissionCallback","connect","interval","connected","success","setInterval","clearInterval","walletOptions","entries","fill","minimal","outlined","img","darkMode","displayName","rightIcon","title","onClose","Classes","addr_list","accts","substr","onChange","setAccountIndex","parseInt","iconProps","icon","defaultValue","accountIndex","App","sessionGetActiveConf","setSessionWallet","accountList","setAccounts","setConnected","basename","document","querySelector","getAttribute","Group","align","Alignment","LEFT","Heading","Divider","RIGHT","exact","path","children","history","createBrowserHistory","ReactDOM","render","StrictMode","getElementById","storageClient","getStorageClient","Web3Storage","storageToken","storage","put","wrapWithDirectory","imgAdded","toFile","ms_threshold","w3s","list","upload","Date","now","updated","req","Request","method","fetch","resp","headers","get","blob","body","parsed","console","error","require","activeConfKey","ac","sessionStorage","getItem","getClient","Algodv2","algod","getDefaultAccount","getSuggested","suggested","create_txn","makeAssetCreateTxnWithSuggestedParamsFromObject","from","assetName","assetURL","assetMetadataHash","toHash","suggestedParams","signTxn","create_txn_s","sendWait","fund_txn","makePaymentTxnWithSuggestedParamsFromObject","to","amount","optin_txn","makeAssetTransferTxnWithSuggestedParamsFromObject","assetIndex","xfer_txn","grouped","assignGroupID","fund_txn_s","xfer_txn_s","optin_txn_s","signTransaction","rx","rounds","getTransactionParams","do","txParams","lastRound","getAssetByID","signed","client","sendRawTransaction","txId","waitForConfirmation","timeout","Error","status","startround","currentround","pendingTransactionInformation","pending","statusAfterBlock"],"mappings":"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","file":"static/js/main.542ff73a.chunk.js","sourcesContent":["import { createToken, getToken } from \"./algorand\"\nimport { getMimeTypeFromIpfs, getMetaFromIpfs } from \"./ipfs\"\nimport { sha256 } from 'js-sha256'\nimport { Wallet } from \"algorand-session-wallet\"\nimport { conf } from \"./config\"\nimport {Metadata} from './metadata'\n\n/*\n\nThe following is a class and metadata type to support the ARC-0003 standard \nset forth by the Algorand Foundation and Community\n\nhttps://github.com/algorandfoundation/ARCs/blob/main/ARCs/arc-0003.md\n\n*/\n\nexport const ARC3_NAME_SUFFIX = \"@arc3\"\nexport const ARC3_URL_SUFFIX = \"#arc3\"\nexport const METADATA_FILE = \"metadata.json\"\nexport const JSON_TYPE = 'application/json'\n\nexport function asaURL(cid: string): string { return ipfsURL(cid)+ARC3_URL_SUFFIX }\nexport function ipfsURL(cid: string): string { return \"ipfs://\"+cid }\nexport function fileURL(activeConf: number, cid: string, name: string): string { return conf[activeConf].ipfsGateway + cid+\"/\"+name }\n\nexport function resolveProtocol(activeConf: number, url: string): string {\n\n    if(url.endsWith(ARC3_URL_SUFFIX)) \n        url = url.slice(0, url.length-ARC3_URL_SUFFIX.length)\n\n    const chunks = url.split(\"://\")\n\n    // No protocol specified, give up\n    if(chunks.length < 2 ) return url\n\n    //Switch on the protocol\n    switch(chunks[0]){\n        case \"ipfs\": //Its ipfs, use the configured gateway\n            return conf[activeConf].ipfsGateway + chunks[1]\n        case \"https\": //Its already http, just return it\n            return url\n        // TODO: Future options may include arweave or algorand\n    }\n\n    return url\n}\n\nexport async function imageIntegrity(file: File): Promise<string> {\n    const buff = await file.arrayBuffer()\n    const bytes = new Uint8Array(buff)\n    const hash = new Uint8Array(sha256.digest(bytes));\n    return \"sha256-\"+Buffer.from(hash).toString(\"base64\")\n}\n\nexport class Token {\n    id:  number \n\n    name: string        \n    unitName: string    \n    url: string         \n\n    metadataHash: string\n\n    total: number       \n    decimals: number    \n\n    creator: string\n\n    manager: string\n    reserve: string\n    clawback: string\n    freeze: string\n\n    defaultFrozen: boolean\n    \n    constructor(t: any) {\n       this.id              = t.id || 0\n       this.name            = t.name || \"\"\n       this.unitName        = t.unitName || \"\"\n       this.url             = t.url || \"\"\n\n       this.metadataHash    = t.metadataHash || \"\"\n\n       this.total           = t.total || 0\n       this.decimals        = t.decimals || 0\n\n       this.creator         = t.creator || \"\"\n\n       this.manager         = t.manager || \"\"\n       this.reserve         = t.reserve || \"\"\n       this.clawback        = t.clawback || \"\"\n       this.freeze          = t.freeze || \"\"\n\n       this.defaultFrozen   = t.defaultFrozen || false\n    }\n\n    static fromParams(t: any ): Token {\n        const p  = t.params\n        return new Token({\n            id              : t.index,\n            name            : p.name || \"\",\n            unitName        : p['unit-name'] || \"\",\n            url             : p.url || \"\",\n            metadataHash    : p['metadata-hash'] || \"\",\n            total           : p.total || 0,\n            decimals        : p.decimals || 0,\n            creator         : p.creator || \"\",\n            manager         : p.manager || \"\",\n            reserve         : p.reserve || \"\",\n            clawback        : p.clawback || \"\",\n            freeze          : p.freeze || \"\",\n            defaultFrozen   : p['default-frozen'] || false,\n        }) as Token\n\n    }\n\n    valid(): boolean {\n        return this.id>0 && this.total>0 && this.url !== \"\"\n    }\n\n}\n\nexport class NFT {\n    token: Token = new Token({})\n    metadata: Metadata = new Metadata()\n\n    urlMimeType: string\n\n    constructor(md: Metadata, token?: Token, urlMimeType?: string) {\n        this.metadata = md\n        this.token = token\n        this.urlMimeType = urlMimeType\n    }\n\n    static async create(wallet: Wallet, activeConf:number, md: Metadata, cid: string): Promise<NFT> {\n        const asset_id = await createToken(wallet, activeConf, ipfsURL(cid), md)\n        return await NFT.fromAssetId(activeConf, asset_id)\n    }\n\n    static async fromAssetId(activeConf: number, assetId: number): Promise<NFT>{\n        return NFT.fromToken(activeConf, await getToken(activeConf, assetId))\n    }\n\n    static async fromToken(activeConf: number, t: any): Promise<NFT> {\n        const token = Token.fromParams(t)\n        const url = resolveProtocol(activeConf, token.url)\n\n        //TODO: provide getters for other storage options\n        // arweave? note field?\n\n        try {\n            const urlMimeType = await getMimeTypeFromIpfs(url)\n\n            switch(urlMimeType){\n                case JSON_TYPE:\n                    return new NFT(await getMetaFromIpfs(url), token, urlMimeType)\n            }\n\n            return new NFT(Metadata.fromToken(token), token, urlMimeType)\n        } catch (error) {\n            return new NFT(new Metadata(), token)    \n        }\n    }\n\n    valid(): boolean {\n       return this.token.valid() && this.metadata.valid()\n    }\n\n    name(): string {\n        if(this.metadata.valid()){\n            return this.metadata.name\n        }\n        if(this.token.valid()){\n            return this.token.name\n        }\n        return \"\"\n    }\n\n    id(): number {\n        return this.token.valid()? this.token.id : 0\n    }\n\n    imgURL(activeConf: number): string {\n        if(!this.valid()) return \"https://dummyimage.com/640x360/fff/aaa\"\n\n\n        // Try to resolve the protocol, if one is set \n        const url = resolveProtocol(activeConf, this.metadata.image)\n\n        // If the url is different, we resolved it correctly\n        if(url !== this.metadata.image) return url\n\n        // It may be a relative url stored within the same directory as the metadata file\n        // Lop off the METADATA_FILE bit and append image path \n        if(this.token.url.endsWith(METADATA_FILE)){\n            const dir = this.token.url.substring(0,this.token.url.length-METADATA_FILE.length)\n            return resolveProtocol(activeConf, dir)+this.metadata.image\n        }\n\n        // give up\n        return url \n    }\n}","import {Token, JSON_TYPE, METADATA_FILE} from './nft'\nimport { sha256 } from 'js-sha256'\n\nexport type Properties = {\n    [key: string]: string | number\n}\n\nexport type LocalizationIntegrity = {\n    [key: string]: string \n}\n\nexport type Localization = {\n    uri: string \n    default: string \n    locales: string[] \n    integrity?: LocalizationIntegrity\n}\n\n\nfunction omitRawAndEmpty(k,v){\n    if(k === \"_raw\") return undefined;\n    if(v === \"\") return undefined;\n    return v\n}\n\nexport class Metadata {\n    _raw: string = undefined\n\n    name: string = \"\"\n    description: string = \"\"\n\n    image: string = \"\"\n    decimals?: number = 0\n    unitName?: string = \"\"\n    image_integrity?: string = \"\"\n    image_mimetype?: string = \"\"\n\n    background_color?: string = \"\"\n    external_url?: string = \"\"\n    external_url_integrity?: string = \"\"\n    external_url_mimetype?: string = \"\"\n\n    animation_url?: string = \"\"\n    animation_url_integrity?: string = \"\"\n    animation_url_mimetype?: string = \"\"\n\n    extra_metadata?: string = \"\"\n\n    localization?: Localization\n\n    properties?: Properties\n\n    constructor(args: any = {}) { Object.assign(this, args) }\n\n    toHash(fmt: Boolean = false): Uint8Array {\n        if(this.hasOwnProperty(\"extra_metadata\")){\n            //TODO\n            //am = SHA-512/256(\"arc0003/am\" || SHA-512/256(\"arc0003/amj\" || content of JSON metadata file) || e)\n        }\n\n        if(this._raw === undefined) \n            this._raw = this.toString(false)\n\n        const hash = sha256.create();\n        fmt ? hash.update(this.toString(false)):hash.update(this._raw);\n        return new Uint8Array(hash.digest())\n    }\n\n    valid(): boolean {\n        return this.image !== \"\"\n    }\n\n    toFile(): File {\n        const md_blob = new Blob([this.toString()], { type: JSON_TYPE })\n        return new File([md_blob], METADATA_FILE)\n    }\n\n    toString(fmt: Boolean = false): string {\n        if(this._raw === undefined) this._raw = JSON.stringify({...this}, omitRawAndEmpty)\n        return JSON.stringify(JSON.parse(this._raw) , omitRawAndEmpty, fmt?2:0)\n    }\n\n    static fromToken(t: Token){\n        return new Metadata({name:t.name, image: t.url, decimals: t.decimals })\n    }\n}\n","import { Card, Elevation } from \"@blueprintjs/core\";\n\nimport React from \"react\";\nimport { Metadata } from \"./lib/metadata\";\nimport { resolveProtocol } from \"./lib/nft\";\nimport {\n  getIpfsUrlFromCID,\n  getMetaFromIpfs,\n  listRecentFiles,\n} from \"./lib/ipfs\";\nimport { SessionWallet } from \"algorand-session-wallet\";\n\ntype PickerProps = {\n  activeConfig: number;\n  sw: SessionWallet\n};\n\n// 4 hours\nconst MAX_DELTA = 60 * 60 * 4 * 1000;\n\nexport default function Picker(props: PickerProps) {\n  const [options, setOptions] = React.useState([]);\n  const [initialized, setInitialized] = React.useState(false);\n\n  // Look at recent\n  React.useEffect(() => {\n    if (initialized) return;\n    listRecentFiles(props.activeConfig, MAX_DELTA).then((opts) => {\n      opts = opts.splice(0, 5);\n      const md_promises = [];\n      for (const idx in opts) {\n        const opt = opts[idx];\n        md_promises.push(\n          getMetaFromIpfs(getIpfsUrlFromCID(props.activeConfig, opt.cid))\n        );\n      }\n      Promise.all(md_promises).then((arr) => {\n        const filtered = [];\n        for (const idx in arr) {\n          if (arr[idx].name !== \"\") filtered.push({\n              cid: opts[idx].cid,\n              md: arr[idx]\n            } as CIDMD);\n        }\n        setOptions(filtered);\n      });\n    });\n    setInitialized(true);\n  }, [props.activeConfig, initialized]);\n\n  const cards = options.map((option) => {\n    return <DisplayCard key={option.cid} cidmd={option} />;\n  });\n\n  return (\n    <div className=\"container\">\n      <div className=\"content content-collection\">{cards}</div>\n    </div>\n  );\n}\n\ntype CIDMD = {\n    cid: string\n    md: Metadata\n}\n\ntype DisplayCardProps = {\n  cidmd: CIDMD;\n};\n\nfunction DisplayCard(props: DisplayCardProps) {\n  return (\n    <Card\n      className=\"content-collection-item\"\n      elevation={Elevation.TWO}\n    >\n        <a href={'/mint/'+props.cidmd.cid}>\n            <img src={resolveProtocol(0, props.cidmd.md.image)} alt=\"nft\" />\n        </a>\n\n    </Card>\n  );\n}\n","import React from 'react'\nimport { Button, Elevation, FileInput, Card} from \"@blueprintjs/core\"\nimport {Metadata} from './lib/metadata'\nimport { putToIPFS } from './lib/ipfs'\n\n//\ntype UploaderProps = {\n    activeConfig: number\n}\n\nexport function Uploader(props: UploaderProps) {\n\n    const [meta, setMeta]               = React.useState(new Metadata())\n    const [loading, setLoading]         = React.useState(false)\n    const [imgSrc, setImgSrc]           = React.useState<string>();\n    const [fileObj, setFileObj]         = React.useState<File>();\n\n    function setFile(file: File) {\n        setFileObj(file)\n\n        const reader = new FileReader();\n        reader.onload = (e: any) => {  setImgSrc(e.target.result) }\n        reader.readAsDataURL(file);\n\n        setMeta((meta)=>{\n            return new Metadata({\n                ...meta,\n                image: file.name,\n                image_mimetype: file.type,\n                properties:{...meta.properties, size:file.size}\n            })\n        })\n    }\n\n\n    async function uploadImage() {\n        setLoading(true) \n        const md = new Metadata({\n            name: \"DRL NFT\",\n            unitName:\"drl-nft\",\n            description:\"NFT Minted at DRL race 1/5/22\",\n            decimals: 0,\n        }) \n\n        setMeta(md)\n\n        try {\n            await putToIPFS(props.activeConfig, fileObj, md)\n            setLoading(false)\n            window.location.reload()\n        } catch (error) {\n            alert(\"Failed to upload image to ipfs :(\")\n            setLoading(false)\n            return\n        }\n    }\n\n    return (\n        <div className='container'>\n            <Card elevation={Elevation.TWO} className='mint-card' >\n                <UploadContainer imgSrc={imgSrc} setFile={setFile} {...meta} />\n                <Button intent='success' style={{float:'right', margin:\"15px\"}} loading={loading} onClick={uploadImage}>Upload</Button>\n            </Card>\n        </div>\n    )\n\n}\n\ntype UploaderContainerProps = {\n    imgSrc: string | undefined\n    setFile(f: File): void\n};\n\nfunction UploadContainer(props: UploaderContainerProps) {\n    function captureFile(event: any) {\n        event.stopPropagation()\n        event.preventDefault()\n        props.setFile(event.target.files.item(0))\n    }\n\n    if (props.imgSrc === undefined || props.imgSrc === \"\" ) return (\n        <div className='container'>\n            <div className='content content-piece' >\n                <FileInput large={true} disabled={false} text=\"Choose file...\" onInputChange={captureFile} />\n            </div>\n        </div>\n    )\n\n\n    return (\n        <div className='container' >\n            <div className='content content-piece'>\n                <img id=\"gateway-link\" alt=\"NFT\" src={props.imgSrc} />\n            </div>\n        </div>\n    )\n}\n","import { SessionWallet } from 'algorand-session-wallet'\nimport QrScanner from \"qr-scanner\";\nimport {useParams} from 'react-router-dom'\nimport React from 'react'\nimport { NFT, resolveProtocol} from './lib/nft'\nimport { Metadata } from './lib/metadata'\nimport { getIpfsUrlFromCID, getMetaFromIpfs } from './lib/ipfs'\nimport {fundAccount, xferAsset} from './lib/algorand'\nimport { Button, Card, Dialog, Elevation } from '@blueprintjs/core'\nimport QRCode from \"react-qr-code\";\nimport algosdk, {secretKeyToMnemonic } from 'algosdk'\nimport { DIALOG_BODY, DIALOG_FOOTER } from '@blueprintjs/core/lib/esm/common/classes'\n\nQrScanner.WORKER_PATH = \"/qr-scanner-worker.min.js\"\n\nexport type MinterProps = {\n    activeConfig: number \n    sw: SessionWallet\n}\n\nexport function Minter(props: MinterProps){\n    // Mint the chosen nft image with our minting account\n    const {cid} = useParams()\n    const [md, setMd] = React.useState(new Metadata({}))\n    const [importingAccount, setImportingAccount] = React.useState(undefined)\n    const [scanningAccount, setScanningAccount] = React.useState(undefined)\n    const [nft, setNFT] = React.useState(undefined)\n\n    React.useEffect(()=>{\n        if(md._raw === undefined)\n            getMetaFromIpfs(getIpfsUrlFromCID(props.activeConfig, cid)).then((md)=>{\n                setMd(md)\n            })\n    }, [props.activeConfig, cid, md])\n\n    async function mintOnly(){\n        // Create ASA with our user\n        const result = await NFT.create(props.sw.wallet, props.activeConfig,  md, cid)\n        setNFT(result)\n        setScanningAccount(result.id())\n    }\n\n    async function handleScannedAccount(addr: string){\n        setScanningAccount(undefined)\n        //Scan their qr\n        await xferAsset(props.sw.wallet, props.activeConfig, addr, nft.id())\n    }\n\n    async function mintAndCreate(){\n        // Create account\n        const acct = algosdk.generateAccount()\n        setImportingAccount(acct)\n    }\n\n    function cancelCreate() { setImportingAccount(undefined) }\n\n    async function continueCreate() {\n        // Create ASA\n        const result = await NFT.create(props.sw.wallet, props.activeConfig,  md, cid)\n\n        // User has scanned it, issue grouped transactions\n        await fundAccount(props.sw.wallet, props.activeConfig, importingAccount, result.id())\n\n        // Unset\n        setImportingAccount(undefined)\n\n        // Nav back to main\n        window.location.href = \"/\"\n    }\n\n    return (\n        <div className='container'>\n            <NFTCard cid={cid} md={md} mintOnly={mintOnly} mintAndCreate={mintAndCreate}></NFTCard>\n            <AccountImporter importingAccount={importingAccount} cancelCreate={cancelCreate} continueCreate={continueCreate}/>\n            <AddressReader  optIn={scanningAccount} handleScanned={handleScannedAccount}></AddressReader>\n        </div>\n    )\n}\n\ninterface NFTCardProps {\n    cid: string\n    md: Metadata\n    mintOnly()\n    mintAndCreate()\n}\n\nfunction NFTCard(props: NFTCardProps) {\n    return (\n        <Card elevation={Elevation.THREE} >\n            <img src={resolveProtocol(0, props.md.image)} alt='nft'></img>\n            <div className='container'>\n                <Button intent='primary' onClick={props.mintOnly}>I have an account</Button>\n                <Button intent='success' onClick={props.mintAndCreate}>Make me an account</Button>\n            </div>\n        </Card>\n    )\n}\n\ninterface AccountImporterProps {\n    importingAccount: algosdk.Account \n    continueCreate()\n    cancelCreate()\n}\n\nfunction AccountImporter(props: AccountImporterProps) {\n    const [isOpen, setIsOpen] = React.useState(false)\n    const [mn, setMn]  = React.useState(\"\")\n\n    const ic = props.importingAccount\n    React.useEffect(()=>{\n        if(ic !== undefined){\n            setMn(JSON.stringify({\n                \"version\":\"1.0\", \n                \"mnemonic\":secretKeyToMnemonic(ic.sk)\n            }))\n            setIsOpen(true)\n        }\n    }, [ic])\n\n    function cancelCreate(){\n        setIsOpen(false)\n        props.cancelCreate()\n    }\n    function continueCreate(){\n        setIsOpen(false)\n        props.continueCreate()\n    }\n\n    return (\n        <Dialog isOpen={isOpen} className='content' >\n            <div className={DIALOG_BODY} >\n                <QRCode  value={mn} />\n            </div>\n            <div className={DIALOG_FOOTER} >\n                <div className='container'>\n                    <Button style={{margin:\"0px 10px\"}} intent='danger' onClick={cancelCreate}>Cancel</Button>\n                    <Button style={{margin:\"0px 10px\"}} intent='success' onClick={continueCreate}>Ready!</Button>\n                </div>\n            </div>\n        </Dialog>\n    )\n}\n\n\n\nexport interface AddressReaderProps {\n    optIn: number \n    handleScanned(addr: string): void\n}\n\nexport function AddressReader(props: AddressReaderProps) {\n    const vref = React.useRef<HTMLVideoElement>(null)\n    const [scanner, setScanner] = React.useState<QrScanner | undefined>(undefined)\n    const [isOpen, setIsOpen] = React.useState(false)\n\n    const open = props.optIn !== undefined && props.optIn>0\n    React.useEffect(()=>{\n        setIsOpen(open)\n        scanner?.stop()\n        scanner?.start()\n    }, [scanner, open])\n\n    let seen = \"\"\n    function initCam(){\n        function handleScanned(data: string){\n            if(seen === data) return\n\n            scanner?.stop()\n            vref.current = null\n            setScanner(undefined)\n            setIsOpen(false)\n            seen = data\n            props.handleScanned(data)\n        }\n\n        if(vref.current !== null && scanner === undefined)\n           setScanner(new QrScanner(vref.current,handleScanned))\n    }\n\n    return (\n        <Dialog isOpen={isOpen} onOpened={initCam}>\n            <div className={DIALOG_BODY}>\n                <h3>Please Opt into Asset ID {props.optIn}</h3>\n                <div className='scanner-container'>\n                    <video style={{width: '100%'}} ref={vref}></video>\n                </div>\n            </div>\n        </Dialog>\n    )\n}","import * as React from 'react'\n\nimport { SessionWallet, allowedWallets } from 'algorand-session-wallet'\n\nimport { Dialog, Button, Classes, HTMLSelect, Intent } from '@blueprintjs/core'\nimport { IconName } from '@blueprintjs/icons'\n\n\ntype AlgorandWalletConnectorProps = {\n    darkMode: boolean\n    connected: boolean\n    accts: string[]\n    sessionWallet: SessionWallet\n    updateWallet(sw: SessionWallet): void\n}\n\nexport default function AlgorandWalletConnector(props:AlgorandWalletConnectorProps)  {\n\n    const [selectorOpen, setSelectorOpen] = React.useState(false)\n\n    const {sessionWallet,updateWallet} = props\n    React.useEffect(()=>{\n        if(sessionWallet.connected()) return\n\n        let interval: any\n        sessionWallet.connect().then((success)=>{\n            if(!success) return\n\n            // Check every 500ms to see if we've connected then kill the interval\n            // This is most useful in the case of walletconnect where it may be several \n            // seconds before the user connects\n            interval = setInterval(()=>{\n                if(sessionWallet.connected()) {\n                    clearInterval(interval)\n                    updateWallet(sessionWallet)\n                }\n            }, 500)\n\n        })\n\n        return ()=>{ clearInterval(interval) }\n\n    }, [sessionWallet, updateWallet])\n\n\n    function disconnectWallet() { \n        props.sessionWallet.disconnect()\n        props.updateWallet(new SessionWallet(props.sessionWallet.network, props.sessionWallet.permissionCallback)) \n    }\n\n    function handleDisplayWalletSelection() { setSelectorOpen(true) }\n\n    async function handleSelectedWallet(e: any) {\n        const choice = e.currentTarget.id\n\n        if(!(choice in allowedWallets)) {\n            if(props.sessionWallet.wallet !== undefined) props.sessionWallet.disconnect()\n            return setSelectorOpen(false)\n        }\n\n        const sw = new SessionWallet(props.sessionWallet.network, props.sessionWallet.permissionCallback, choice)\n\n        if(!await sw.connect()) {\n            sw.disconnect()\n        }\n\n        props.updateWallet(sw)\n\n        setSelectorOpen(false)\n    }\n\n    function handleChangeAccount(e: any) {\n        props.sessionWallet.setAccountIndex(parseInt(e.target.value))\n        props.updateWallet(props.sessionWallet)\n    }\n\n    const walletOptions = []\n    for(const [k,v] of Object.entries(allowedWallets)){\n        walletOptions.push((\n        <li key={k}>\n            <Button id={k}\n                large={true} \n                fill={true} \n                minimal={true} \n                outlined={true} \n                onClick={handleSelectedWallet}\n                > \n                <div className='wallet-option'>\n                    <img alt='wallet-branding' className='wallet-branding' src={  v.img(props.darkMode)} />\n                    <h5>{v.displayName()}</h5>\n                </div>\n                </Button>\n        </li>\n        ))\n    }\n\n    if (!props.connected) return (\n        <div>\n            <Button\n                minimal={true}\n                rightIcon='selection'\n                intent='warning'\n                outlined={true}\n                onClick={handleDisplayWalletSelection}>Connect Wallet</Button>\n\n            <Dialog isOpen={selectorOpen} title='Select Wallet' onClose={handleSelectedWallet} >\n                <div className={Classes.DIALOG_BODY}>\n                    <ul className='wallet-option-list'>\n                        {walletOptions}\n                    </ul>\n                </div>\n            </Dialog>\n        </div>\n    )\n\n\n    const addr_list = props.accts.map((addr, idx) => {\n        return (<option value={idx} key={idx}> {addr.substr(0, 8)}...  </option>)\n    })\n\n    const iconprops = { \n        icon: 'symbol-circle' as IconName, \n        intent: 'success'  as Intent\n    }\n\n    return (\n        <div>\n            <HTMLSelect \n                onChange={handleChangeAccount} \n                minimal={true} \n                iconProps={iconprops} \n                defaultValue={props.sessionWallet.accountIndex()} >\n                {addr_list}\n            </HTMLSelect>\n            <Button icon='log-out' minimal={true} onClick={disconnectWallet} ></Button>\n        </div>\n    )\n}","import Picker from './Picker'\nimport './index.css';\nimport { AnchorButton, Alignment, Navbar } from '@blueprintjs/core';\nimport { SessionWallet } from 'algorand-session-wallet';\nimport {Uploader} from './Uploader'\nimport React from 'react';\nimport {Minter} from './Minter';\nimport AlgorandWalletConnector from './AlgorandWalletConnector'\nimport { conf, sessionGetActiveConf } from './lib/config';\n\nimport {\n  BrowserRouter as Router,\n  Switch,\n  Route,\n} from 'react-router-dom'\n\n\ntype AppProps = {\n  history: History,\n}\n\nfunction App(props: AppProps) {\n\n  const activeConf = sessionGetActiveConf()\n\n  const sw = new SessionWallet(conf[activeConf].network)\n\n\n  const [sessionWallet, setSessionWallet] =  React.useState(sw)\n  const [accts, setAccounts] = React.useState(sw.accountList())\n  const [connected, setConnected] = React.useState(sw.connected())\n\n  function updateWallet(sw: SessionWallet){ \n    setSessionWallet(sw)\n    setAccounts(sw.accountList())\n    setConnected(sw.connected())\n  }\n  const basename = document.querySelector('base')?.getAttribute('href') ?? '/'    \n\n  return (\n    <Router basename={basename}>\n      <div className=\"App\">\n        <Navbar>\n        <Navbar.Group align={Alignment.LEFT}>\n          <Navbar.Heading>Algorand NFT Minter</Navbar.Heading>\n          <Navbar.Divider />\n          <AnchorButton minimal={true} icon='search' href={basename+'/'} text='Choose' />\n          <AnchorButton minimal={true} icon='upload' href={basename+'/upload'} text='Upload' />\n        </Navbar.Group>\n        <Navbar.Group  align={Alignment.RIGHT}>\n          <AlgorandWalletConnector  \n            darkMode={false}\n            sessionWallet={sessionWallet}\n            accts={accts}\n            connected={connected} \n            updateWallet={updateWallet}\n          />\n\n        </Navbar.Group>\n        </Navbar>\n        <Switch>\n          <Route exact path=\"/\" children={<Picker  activeConfig={activeConf} sw={sessionWallet}></Picker>} />\n          <Route path=\"/mint/:cid\" children={ <Minter  activeConfig={activeConf} sw={sessionWallet}></Minter> }/>\n          <Route exact path=\"/upload\" children={ <Uploader  activeConfig={activeConf} ></Uploader> }/>\n        </Switch>\n      </div>\n    </Router>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\n\n\nimport {createBrowserHistory} from \"history\"\n\nconst history = createBrowserHistory();\n\nReactDOM.render(\n  <React.StrictMode>\n    <App history={history}  />\n  </React.StrictMode>,\n  document.getElementById('root')\n);","import { ipfsURL } from './nft'\nimport {Metadata} from './metadata'\nimport {conf} from './config'\n\n/*\n Currently an issue with resolving ipfs-car module in web3.storage when using react-scripts\n We just use the prebuilt one but with no types we have to just ignore the issue for now\n//import { Web3Storage } from 'web3.storage'\n*/\n// @ts-ignore\nimport { Web3Storage } from 'web3.storage/dist/bundle.esm.min.js'\n\n\nlet storageClient = undefined\nfunction getStorageClient(activeConf: number): Web3Storage {\n    if(storageClient === undefined){\n        storageClient = new Web3Storage({ token: conf[activeConf].storageToken })\n    }\n    return storageClient\n}\n\nexport async function putToIPFS(activeConf: number, file: File, md: Metadata): Promise<string> {\n    const storage = getStorageClient(activeConf) \n    const imgAdded = await storage.put([file], {wrapWithDirectory: false})\n    md.image = ipfsURL(imgAdded)\n\n    return await storage.put([md.toFile()], {wrapWithDirectory: false})\n}\n\nexport async function listRecentFiles( activeConf: number, ms_threshold: number): Promise<any[]> {\n    const w3s = getStorageClient(activeConf)\n    const options = []\n    for await (const upload of w3s.list()) {\n        const delta = Date.now() - Date.parse(upload.updated)\n        if(delta<ms_threshold){\n            options.push(upload)\n            continue\n        }\n        return options\n    }\n    return options\n}\n\nexport function getIpfsUrlFromCID(activeConf:number, cid: string): string {\n    return conf[activeConf].ipfsGateway + cid\n}\n\nexport async function getMimeTypeFromIpfs(url: string): Promise<string> {\n    const req = new Request(url, { method:\"HEAD\" })\n    const resp = await fetch(req)\n    return resp.headers.get(\"Content-Type\")\n}\n\n\nexport async function getMetaFromIpfs(url: string): Promise<Metadata> {\n    try {\n        const req = new Request(url)\n        const resp = await fetch(req)\n        const body = await resp.blob()\n        const text = await body.text()\n        const parsed = JSON.parse(text)\n        return new Metadata({\"_raw\":text, ...parsed}) \n    } catch (e){\n        console.error(e)\n    }\n\n    return new Metadata({})\n}","type Config = {\n    network: string;       // The network to use for creating nfts\n    storageToken: string;  // The token provided by web3.storage\n    ipfsGateway: string;   // The IPFS gateway url for retrieving files\n    algod: string          // The Algod api url to use\n    blockExplorer: string; // The Block Explorer to allow linking out to\n}\n\nexport const conf = require(\"../config.json\") as Config[];\n\nexport function getAddrUrl(idx: number, addr: string): string {\n    return conf[idx].blockExplorer + \"address/\" + addr\n}\nexport function getAsaUrl(idx: number, id: number): string {\n    return conf[idx].blockExplorer + \"asset/\" + id \n}\n\nconst activeConfKey = \"active-conf\"\nexport function sessionGetActiveConf(): number {\n    const ac = sessionStorage.getItem(activeConfKey)\n    if(ac === undefined || ac === null) return 0\n    return parseInt(ac)\n}\n\nexport function sessionSetActiveConf(ac: number)  {\n    sessionStorage.setItem(activeConfKey, ac.toString())\n}\n","import { Wallet } from \"algorand-session-wallet\";\nimport algosdk, {\n  Algodv2,\n  makeAssetCreateTxnWithSuggestedParamsFromObject,\n  makeAssetTransferTxnWithSuggestedParamsFromObject,\n  makePaymentTxnWithSuggestedParamsFromObject,\n} from \"algosdk\";\nimport { NFT } from \"./nft\";\nimport { Metadata } from \"./metadata\";\nimport { conf } from \"./config\";\n\nfunction getClient(activeConf: number): Algodv2 {\n  return new algosdk.Algodv2(\"\", conf[activeConf].algod, \"\");\n}\n\nexport async function createToken(\n  wallet: Wallet,\n  activeConf: number,\n  url: string,\n  md: Metadata\n): Promise<number> {\n  const addr = wallet.getDefaultAccount();\n  const suggested = await getSuggested(activeConf, 100);\n\n  const create_txn = makeAssetCreateTxnWithSuggestedParamsFromObject({\n    from: addr,\n    assetName: md.name,\n    unitName: md.unitName,\n    assetURL: url,\n    assetMetadataHash: md.toHash(),\n    manager: addr,\n    total: 1,\n    decimals: 0,\n    defaultFrozen: false,\n    suggestedParams: suggested,\n  });\n\n  const [create_txn_s]  = await wallet.signTxn([create_txn])\n  const result = await sendWait(activeConf, [create_txn_s])\n  return result['asset-index']\n}\n\nexport async function fundAccount(\n  wallet: Wallet,\n  activeConf: number,\n  acct: algosdk.Account,\n  id: number\n) {\n  const addr = wallet.getDefaultAccount();\n  const suggested = await getSuggested(activeConf, 100);\n\n  const fund_txn = makePaymentTxnWithSuggestedParamsFromObject({\n    from: addr,\n    to: acct.addr,\n    amount: 3e6,\n    suggestedParams: suggested,\n  });\n\n  const optin_txn = makeAssetTransferTxnWithSuggestedParamsFromObject({\n    from: acct.addr,\n    to: acct.addr,\n    assetIndex: id,\n    amount: 0,\n    suggestedParams: suggested,\n  });\n\n  const xfer_txn = makeAssetTransferTxnWithSuggestedParamsFromObject({\n    from: addr,\n    to: acct.addr,\n    assetIndex: id,\n    amount: 1,\n    suggestedParams: suggested,\n  });\n\n\n  const grouped = [fund_txn, optin_txn, xfer_txn];\n  algosdk.assignGroupID(grouped);\n\n  // @ts-ignore\n  const [fund_txn_s, _, xfer_txn_s] = await wallet.signTxn(grouped);\n  const optin_txn_s = algosdk.signTransaction(optin_txn, acct.sk);\n  await sendWait(activeConf, [fund_txn_s, optin_txn_s, xfer_txn_s]);\n}\n\nexport async function xferAsset(\n  wallet: Wallet,\n  activeConf: number,\n  rx: string,\n  id: number\n) {\n  const addr = wallet.getDefaultAccount();\n  const suggested = await getSuggested(activeConf, 100);\n\n  const xfer_txn = makeAssetTransferTxnWithSuggestedParamsFromObject({\n    from: addr,\n    to: rx,\n    assetIndex: id,\n    amount: 1,\n    suggestedParams: suggested,\n  });\n\n  const [create_txn_s] = await wallet.signTxn([xfer_txn]);\n  await sendWait(activeConf, [create_txn_s]);\n}\n\nexport async function getSuggested(activeConf: number, rounds: number) {\n  const txParams = await getClient(activeConf).getTransactionParams().do();\n  return { ...txParams, lastRound: txParams[\"firstRound\"] + rounds };\n}\n\nexport async function getToken(\n  activeConf: number,\n  assetId: number\n): Promise<any> {\n  return await getClient(activeConf).getAssetByID(assetId).do();\n}\n\nexport async function getCollection(\n  activeConf: number,\n  address: string\n): Promise<any[]> {\n  const results = await getClient(activeConf).accountInformation(address).do();\n\n  const plist = [];\n  for (const a in results[\"assets\"]) {\n    if (results[\"assets\"][a][\"amount\"] > 0)\n      plist.push(getToken(activeConf, results[\"assets\"][a][\"asset-id\"]));\n  }\n\n  const assets = await Promise.all(plist);\n  const collectionRequests = assets.map((a) => {\n    return NFT.fromToken(activeConf, a);\n  });\n  return Promise.all(collectionRequests);\n}\n\nexport async function sendWait(\n  activeConf: number,\n  signed: any[]\n): Promise<any> {\n  const client = getClient(activeConf);\n  try {\n    const { txId } = await client\n      .sendRawTransaction(\n        signed.map((t) => {\n          return t.blob;\n        })\n      )\n      .do();\n    const result = await waitForConfirmation(client, txId, 3);\n    return result;\n  } catch (error) {\n    console.error(error);\n  }\n\n  return undefined;\n}\n\nasync function waitForConfirmation(client, txId, timeout) {\n  if (client == null || txId == null || timeout < 0) {\n    throw new Error(\"Bad arguments.\");\n  }\n\n  const status = await client.status().do();\n  if (typeof status === \"undefined\")\n    throw new Error(\"Unable to get node status\");\n\n  const startround = status[\"last-round\"] + 1;\n  let currentround = startround;\n\n  /* eslint-disable no-await-in-loop */\n  while (currentround < startround + timeout) {\n    const pending = await client.pendingTransactionInformation(txId).do();\n\n    if (pending !== undefined) {\n      if (pending[\"confirmed-round\"] !== null && pending[\"confirmed-round\"] > 0)\n        return pending;\n\n      if (pending[\"pool-error\"] != null && pending[\"pool-error\"].length > 0)\n        throw new Error(\n          `Transaction Rejected pool error${pending[\"pool-error\"]}`\n        );\n    }\n\n    await client.statusAfterBlock(currentround).do();\n    currentround += 1;\n  }\n\n  /* eslint-enable no-await-in-loop */\n  throw new Error(`Transaction not confirmed after ${timeout} rounds!`);\n}\n"],"sourceRoot":""}