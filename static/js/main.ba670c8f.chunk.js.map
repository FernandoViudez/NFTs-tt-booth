{"version":3,"sources":["lib/metadata.ts","lib/nft.ts","lib/ipfs.ts","MediaDisplay.tsx","Picker.tsx","Uploader.tsx","Minter.tsx","AlgorandWalletConnector.tsx","App.tsx","index.tsx","lib/config.ts","lib/algorand.ts"],"names":["getTypeFromMimeType","filetype","split","type","omitRawAndEmpty","k","v","Metadata","args","_raw","undefined","name","description","image","decimals","unitName","image_integrity","image_mimetype","background_color","external_url","external_url_integrity","external_url_mimetype","animation_url","animation_url_integrity","animation_url_mimetype","extra_metadata","localization","properties","Object","assign","this","fmt","hasOwnProperty","toString","hash","sha256","create","update","Uint8Array","digest","md_blob","Blob","JSON_TYPE","File","METADATA_FILE","title","JSON","stringify","parse","mimeType","t","url","ARC3_URL_SUFFIX","ipfsURL","cid","resolveProtocol","activeConf","endsWith","slice","length","chunks","conf","ipfsGateway","mediaIntegrity","file","a","arrayBuffer","buff","bytes","Buffer","from","Token","id","metadataHash","total","creator","manager","reserve","clawback","freeze","defaultFrozen","p","params","index","NFT","md","token","urlMimeType","metadata","valid","mediaURL","substring","wallet","createToken","asset_id","fromAssetId","assetId","getToken","fromToken","fromParams","getMimeTypeFromIpfs","getMetaFromIpfs","storageClient","getStorageClient","Web3Storage","endpoint","putToIPFS","storage","put","wrapWithDirectory","mediaAdded","integ","mdc","mediaType","mdobj","toFile","listRecentFiles","ms_threshold","w3s","options","list","maxResults","upload","push","getIpfsUrlFromCID","req","Request","method","fetch","resp","headers","get","blob","body","text","parsed","console","error","MediaDisplay","props","media","controls","src","mediaSrc","alt","className","MAX_DELTA","Picker","React","useState","setOptions","initialized","setInitialized","activeConfig","opts","mime_type_promises","opt","Promise","all","idx","mimeTypes","md_promises","metas","filtered","useEffect","getRecentFiles","then","cards","map","option","DisplayCard","cidmd","to","elevation","Elevation","TWO","Uploader","meta","setMeta","setTitle","loading","setLoading","fileObj","setFileObj","setMediaSrc","setMimeType","window","location","reload","alert","UploadContainer","mediaTitle","setFile","reader","FileReader","onload","e","target","result","readAsDataURL","metaObj","size","intent","style","float","margin","onClick","large","disabled","onInputChange","event","stopPropagation","preventDefault","files","item","Minter","useParams","setMd","importingAccount","setImportingAccount","nft","setNFT","fundLoading","setFundLoading","popupOpen","setPopupOpen","createdId","setCreatedId","sw","addr","xferAsset","acct","algosdk","generateAccount","fundAccount","href","NFTCard","mintOnly","mintAndCreate","AccountImporter","cancelCreate","continueCreate","AddressReader","optIn","handleScanned","isOpen","DIALOG_BODY","THREE","icon","setIsOpen","mn","setMn","ic","secretKeyToMnemonic","sk","value","DIALOG_FOOTER","vref","useRef","scanner","setScanner","open","stop","start","seen","onOpened","current","QrScanner","data","width","ref","WORKER_PATH","AlgorandWalletConnector","selectorOpen","setSelectorOpen","sessionWallet","updateWallet","handleSelectedWallet","choice","currentTarget","allowedWallets","disconnect","SessionWallet","network","permissionCallback","connect","interval","connected","success","setInterval","clearInterval","walletOptions","entries","fill","minimal","outlined","img","darkMode","displayName","rightIcon","onClose","Classes","addr_list","accts","substr","onChange","setAccountIndex","parseInt","iconProps","defaultValue","accountIndex","App","sessionGetActiveConf","setSessionWallet","accountList","setAccounts","setConnected","Group","align","Alignment","LEFT","Heading","Divider","RIGHT","exact","path","children","history","createBrowserHistory","ReactDOM","render","StrictMode","document","getElementById","require","activeConfKey","ac","sessionStorage","getItem","getClient","Algodv2","algod","getDefaultAccount","getSuggested","suggested","create_txn","makeAssetCreateTxnWithSuggestedParamsFromObject","assetName","assetURL","assetMetadataHash","toHash","suggestedParams","signTxn","create_txn_s","sendWait","fund_txn","makePaymentTxnWithSuggestedParamsFromObject","amount","optin_txn","makeAssetTransferTxnWithSuggestedParamsFromObject","assetIndex","xfer_txn","grouped","assignGroupID","fund_txn_s","xfer_txn_s","optin_txn_s","signTransaction","rx","rounds","getTransactionParams","do","txParams","lastRound","getAssetByID","signed","client","sendRawTransaction","txId","waitForConfirmation"],"mappings":"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","file":"static/js/main.ba670c8f.chunk.js","sourcesContent":["import {Token, JSON_TYPE, METADATA_FILE} from './nft'\nimport { sha256 } from 'js-sha256'\n\nexport type Properties = {\n    [key: string]: string | number\n}\n\nexport type LocalizationIntegrity = {\n    [key: string]: string \n}\n\nexport type Localization = {\n    uri: string \n    default: string \n    locales: string[] \n    integrity?: LocalizationIntegrity\n}\n\n// Just takes the first chunk of the mimetype (the type)\nexport function getTypeFromMimeType(filetype: string): string {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const [type, _] = filetype.split(\"/\")\n    return type\n}\n\nfunction omitRawAndEmpty(k,v){\n    if(k === \"_raw\") return undefined;\n    if(v === \"\") return undefined;\n    return v\n}\n\nexport class Metadata {\n    _raw: string = undefined\n\n    name: string = \"\"\n    description: string = \"\"\n\n    image: string = \"\"\n    decimals?: number = 0\n    unitName?: string = \"\"\n    image_integrity?: string = \"\"\n    image_mimetype?: string = \"\"\n\n    background_color?: string = \"\"\n    external_url?: string = \"\"\n    external_url_integrity?: string = \"\"\n    external_url_mimetype?: string = \"\"\n\n    animation_url?: string = \"\"\n    animation_url_integrity?: string = \"\"\n    animation_url_mimetype?: string = \"\"\n\n    extra_metadata?: string = \"\"\n\n    localization?: Localization\n\n    properties?: Properties\n\n    constructor(args: any = {}) { Object.assign(this, args) }\n\n    toHash(fmt: Boolean = false): Uint8Array {\n        if(this.hasOwnProperty(\"extra_metadata\")){\n            //TODO\n            //am = SHA-512/256(\"arc0003/am\" || SHA-512/256(\"arc0003/amj\" || content of JSON metadata file) || e)\n        }\n\n        if(this._raw === undefined) \n            this._raw = this.toString(false)\n\n        const hash = sha256.create();\n        fmt ? hash.update(this.toString(false)):hash.update(this._raw);\n        return new Uint8Array(hash.digest())\n    }\n\n    valid(): boolean {\n        return this.image !== \"\"\n    }\n\n    toFile(): File {\n        const md_blob = new Blob([this.toString()], { type: JSON_TYPE })\n        return new File([md_blob], METADATA_FILE)\n    }\n\n    title(): string {\n        if(this.properties !== undefined && 'title' in this.properties) return this.properties.title.toString()\n        return this.name\n    }\n\n    toString(fmt: Boolean = false): string {\n        if(this._raw === undefined) this._raw = JSON.stringify({...this}, omitRawAndEmpty)\n        return JSON.stringify(JSON.parse(this._raw) , omitRawAndEmpty, fmt?2:0)\n    }\n\n\n    mimeType(): string {\n        if(this.animation_url !== \"\") return this.animation_url_mimetype;\n        if(this.external_url_mimetype !== \"\") return this.external_url_mimetype;\n        return this.image_mimetype\n    }\n\n    mediaType(): string {\n        return getTypeFromMimeType(this.mimeType())\n    }\n\n    mediaURL(): string {\n        if(this.animation_url !== \"\") {\n            return this.animation_url\n        }\n        return this.image\n    }\n\n\n    static fromToken(t: Token){\n        return new Metadata({name:t.name, image: t.url, decimals: t.decimals })\n    }\n}\n","import { createToken, getToken } from \"./algorand\";\nimport { getMimeTypeFromIpfs, getMetaFromIpfs } from \"./ipfs\";\nimport { sha256 } from \"js-sha256\";\nimport { Wallet } from \"algorand-session-wallet\";\nimport { conf } from \"./config\";\nimport { Metadata } from \"./metadata\";\n\n/*\n\nThe following is a class and metadata type to support the ARC-0003 standard \nset forth by the Algorand Foundation and Community\n\nhttps://github.com/algorandfoundation/ARCs/blob/main/ARCs/arc-0003.md\n\n*/\n\nexport const ARC3_NAME_SUFFIX = \"@arc3\";\nexport const ARC3_URL_SUFFIX = \"#arc3\";\nexport const METADATA_FILE = \"metadata.json\";\nexport const JSON_TYPE = \"application/json\";\n\nexport function asaURL(cid: string): string {\n  return ipfsURL(cid) + ARC3_URL_SUFFIX;\n}\nexport function ipfsURL(cid: string): string {\n  return \"ipfs://\" + cid;\n}\nexport function fileURL(activeConf: number, cid: string, name: string): string {\n  return conf[activeConf].ipfsGateway + cid + \"/\" + name;\n}\n\nexport function resolveProtocol(activeConf: number, url: string): string {\n  if (url.endsWith(ARC3_URL_SUFFIX))\n    url = url.slice(0, url.length - ARC3_URL_SUFFIX.length);\n\n  const chunks = url.split(\"://\");\n\n  // No protocol specified, give up\n  if (chunks.length < 2) return url;\n\n  //Switch on the protocol\n  switch (chunks[0]) {\n    case \"ipfs\": //Its ipfs, use the configured gateway\n      return conf[activeConf].ipfsGateway + chunks[1];\n    case \"https\": //Its already http, just return it\n      return url;\n    // TODO: Future options may include arweave or algorand\n  }\n\n  return url;\n}\n\nexport async function mediaIntegrity(file: File): Promise<string> {\n  const buff = await file.arrayBuffer();\n  const bytes = new Uint8Array(buff);\n  const hash = new Uint8Array(sha256.digest(bytes));\n  return \"sha256-\" + Buffer.from(hash).toString(\"base64\");\n}\n\nexport class Token {\n  id: number;\n\n  name: string;\n  unitName: string;\n  url: string;\n\n  metadataHash: string;\n\n  total: number;\n  decimals: number;\n\n  creator: string;\n\n  manager: string;\n  reserve: string;\n  clawback: string;\n  freeze: string;\n\n  defaultFrozen: boolean;\n\n  constructor(t: any) {\n    this.id = t.id || 0;\n    this.name = t.name || \"\";\n    this.unitName = t.unitName || \"\";\n    this.url = t.url || \"\";\n\n    this.metadataHash = t.metadataHash || \"\";\n\n    this.total = t.total || 0;\n    this.decimals = t.decimals || 0;\n\n    this.creator = t.creator || \"\";\n\n    this.manager = t.manager || \"\";\n    this.reserve = t.reserve || \"\";\n    this.clawback = t.clawback || \"\";\n    this.freeze = t.freeze || \"\";\n\n    this.defaultFrozen = t.defaultFrozen || false;\n  }\n\n  static fromParams(t: any): Token {\n    const p = t.params;\n    return new Token({\n      id: t.index,\n      name: p.name || \"\",\n      unitName: p[\"unit-name\"] || \"\",\n      url: p.url || \"\",\n      metadataHash: p[\"metadata-hash\"] || \"\",\n      total: p.total || 0,\n      decimals: p.decimals || 0,\n      creator: p.creator || \"\",\n      manager: p.manager || \"\",\n      reserve: p.reserve || \"\",\n      clawback: p.clawback || \"\",\n      freeze: p.freeze || \"\",\n      defaultFrozen: p[\"default-frozen\"] || false,\n    }) as Token;\n  }\n\n  valid(): boolean {\n    return this.id > 0 && this.total > 0 && this.url !== \"\";\n  }\n}\n\nexport class NFT {\n  token: Token = new Token({});\n  metadata: Metadata = new Metadata();\n\n  urlMimeType: string;\n\n  constructor(md: Metadata, token?: Token, urlMimeType?: string) {\n    this.metadata = md;\n    this.token = token;\n    this.urlMimeType = urlMimeType;\n  }\n\n  static async create(\n    wallet: Wallet,\n    activeConf: number,\n    md: Metadata,\n    cid: string\n  ): Promise<NFT> {\n    const asset_id = await createToken(wallet, activeConf, ipfsURL(cid), md);\n    return await NFT.fromAssetId(activeConf, asset_id);\n  }\n\n  static async fromAssetId(activeConf: number, assetId: number): Promise<NFT> {\n    return NFT.fromToken(activeConf, await getToken(activeConf, assetId));\n  }\n\n  static async fromToken(activeConf: number, t: any): Promise<NFT> {\n    const token = Token.fromParams(t);\n    const url = resolveProtocol(activeConf, token.url);\n\n    //TODO: provide getters for other storage options\n    // arweave? note field?\n\n    try {\n      const urlMimeType = await getMimeTypeFromIpfs(url);\n\n      switch (urlMimeType) {\n        case JSON_TYPE:\n          return new NFT(await getMetaFromIpfs(url), token, urlMimeType);\n      }\n\n      return new NFT(Metadata.fromToken(token), token, urlMimeType);\n    } catch (error) {\n      return new NFT(new Metadata(), token);\n    }\n  }\n\n  valid(): boolean {\n    return this.token.valid() && this.metadata.valid();\n  }\n\n  name(): string {\n    if (this.metadata.valid()) {\n      return this.metadata.name;\n    }\n    if (this.token.valid()) {\n      return this.token.name;\n    }\n    return \"\";\n  }\n\n  id(): number {\n    return this.token.valid() ? this.token.id : 0;\n  }\n\n  mediaURL(activeConf: number): string {\n    if (!this.valid()) return \"https://dummyimage.com/640x360/fff/aaa\";\n\n    // Try to resolve the protocol, if one is set\n    const url = resolveProtocol(activeConf, this.metadata.mediaURL());\n\n    // If the url is different, we resolved it correctly\n    if (url !== this.metadata.mediaURL()) return url;\n\n    // It may be a relative url stored within the same directory as the metadata file\n    // Lop off the METADATA_FILE bit and append image path\n    if (this.token.url.endsWith(METADATA_FILE)) {\n      const dir = this.token.url.substring(\n        0,\n        this.token.url.length - METADATA_FILE.length\n      );\n      return resolveProtocol(activeConf, dir) + this.metadata.mediaURL();\n    }\n\n    // give up\n    return url;\n  }\n}\n","import { ipfsURL, mediaIntegrity } from './nft'\nimport {Metadata} from './metadata'\nimport {conf} from './config'\n\n/*\n Currently an issue with resolving ipfs-car module in web3.storage when using react-scripts\n We just use the prebuilt one but with no types we have to just ignore the issue for now\n//import { Web3Storage } from 'web3.storage'\n*/\n// @ts-ignore\nimport { Web3Storage } from 'web3.storage/dist/bundle.esm.min.js'\n\n\nlet storageClient = undefined\nfunction getStorageClient(activeConf: number): Web3Storage {\n    if(storageClient === undefined){\n        storageClient = new Web3Storage({ token: \" \", endpoint:\"https://worker.barnji.workers.dev\" })\n    }\n    return storageClient\n}\n\nexport async function putToIPFS(activeConf: number, file: File, md: Metadata): Promise<string> {\n    const storage = getStorageClient(activeConf) \n    const mediaAdded = await storage.put([file], {wrapWithDirectory: false})\n\n    const integ = await mediaIntegrity(file)\n\n    const mdc = {...md}\n    switch(md.mediaType()){\n        case 'image':\n            mdc.image = ipfsURL(mediaAdded)\n            mdc.image_integrity = integ\n            break\n        case 'audio':\n            mdc.animation_url = ipfsURL(mediaAdded)\n            mdc.animation_url_integrity = integ\n            break\n        case 'video':\n            mdc.animation_url = ipfsURL(mediaAdded)\n            mdc.animation_url_integrity = integ\n            break\n    }\n\n    const mdobj = new Metadata(mdc)\n\n    return await storage.put([mdobj.toFile()], {wrapWithDirectory: false})\n}\n\nexport async function listRecentFiles( activeConf: number, ms_threshold: number): Promise<any[]> {\n    const w3s = getStorageClient(activeConf)\n    const options = []\n    for await (const upload of w3s.list({maxResults:20})) {\n        options.push(upload)\n    }\n    return options\n}\n\nexport function getIpfsUrlFromCID(activeConf:number, cid: string): string {\n    return conf[activeConf].ipfsGateway + cid\n}\n\nexport async function getMimeTypeFromIpfs(url: string): Promise<string> {\n    const req = new Request(url, { method:\"HEAD\" })\n    const resp = await fetch(req)\n    return resp.headers.get(\"Content-Type\")\n}\n\n\nexport async function getMetaFromIpfs(url: string): Promise<Metadata> {\n    try {\n        const req = new Request(url)\n        const resp = await fetch(req)\n        const body = await resp.blob()\n        const text = await body.text()\n        const parsed = JSON.parse(text)\n        return new Metadata({\"_raw\":text, ...parsed}) \n    } catch (e){\n        console.error(e)\n    }\n\n    return new Metadata({})\n}","import { getTypeFromMimeType } from \"./lib/metadata\"\n\ntype MediaDisplayProps = {\n    title: string\n    mimeType: string\n    mediaSrc: string | undefined\n}\n\nexport function MediaDisplay(props: MediaDisplayProps){\n    const type = getTypeFromMimeType(props.mimeType)\n\n    let media = <div></div>\n    switch(type) {\n        case \"audio\":\n           media = (\n                <audio id=\"uploaded-media\" controls >\n                    <source src={props.mediaSrc} type={props.mimeType} />\n                </audio>\n            )\n            break;\n        case \"video\":\n            media = (\n                <video id=\"uploaded-media\" controls>\n                    <source src={props.mediaSrc} type={props.mimeType} />\n                </video>\n            )\n            break;\n        default:\n            media = (\n                <img id=\"uploaded-media\" alt=\"NFT\" src={props.mediaSrc} />\n            )\n    }\n\n    return (\n        <div className='media-display container'>\n\n            <h3>{props.title}</h3>\n\n            <div className='content' > \n                {media}\n            </div>\n        </div>\n    )\n}","import { Card, Elevation } from \"@blueprintjs/core\";\n\nimport { Link } from 'react-router-dom'\nimport React from \"react\";\nimport { Metadata } from \"./lib/metadata\";\nimport { resolveProtocol } from \"./lib/nft\";\nimport {\n  getIpfsUrlFromCID,\n  getMetaFromIpfs,\n  getMimeTypeFromIpfs,\n  listRecentFiles,\n} from \"./lib/ipfs\";\nimport { SessionWallet } from \"algorand-session-wallet\";\nimport { MediaDisplay } from \"./MediaDisplay\";\n\ntype PickerProps = {\n  activeConfig: number;\n  sw: SessionWallet\n};\n\n// 2 hours\nconst MAX_DELTA = 60 * 60 * 4 * 1000;\n\n\nexport default function Picker(props: PickerProps) {\n  const [options, setOptions] = React.useState([]);\n  const [initialized, setInitialized] = React.useState(false);\n\n\n  async function getRecentFiles(activeConfig: number): Promise<CIDMD[]> {\n    const opts = await listRecentFiles(activeConfig, MAX_DELTA)\n\n    const mime_type_promises = []\n    for (const opt of opts) {\n      mime_type_promises.push(getMimeTypeFromIpfs(getIpfsUrlFromCID(props.activeConfig, opt.cid)))\n    }\n\n    const mimeTypes = await Promise.all(mime_type_promises)\n\n    const md_promises = [];\n    for (const idx in opts) {\n      if (mimeTypes[idx] === \"application/json\")\n        md_promises.push(\n          getMetaFromIpfs(getIpfsUrlFromCID(props.activeConfig, opts[idx].cid))\n        );\n    }\n\n    const metas = await Promise.all(md_promises)\n    const filtered = [];\n    for (const idx in metas) {\n      if (metas[idx].name === \"\") continue;\n\n      filtered.push({\n        cid: opts[idx].cid,\n        md: metas[idx]\n      } as CIDMD);\n    }\n\n    return filtered\n  }\n\n  // Look at recent\n  React.useEffect(() => {\n    if (initialized) return;\n\n    getRecentFiles(props.activeConfig).then((filtered) => {\n      setOptions(filtered);\n      setInitialized(true);\n    })\n\n  }, [props.activeConfig, initialized]);\n\n  const cards = initialized ? options.map((option) => {\n    return <DisplayCard key={option.cid} cidmd={option} />;\n  }) : [<h5 key='loading'>Loading...</h5>];\n\n  return (\n    <div className=\"container\">\n      <div className=\"content content-collection\">\n        {cards}\n      </div>\n    </div>\n  );\n}\n\ntype CIDMD = {\n  cid: string\n  md: Metadata\n}\n\ntype DisplayCardProps = {\n  cidmd: CIDMD;\n};\n\nfunction DisplayCard(props: DisplayCardProps) {\n  return (\n\n    <Link to={'/mint/' + props.cidmd.cid}>\n      <Card\n        className=\"content-collection-item\"\n        elevation={Elevation.TWO}\n      >\n        <MediaDisplay\n          title={props.cidmd.md.title()}\n          mediaSrc={resolveProtocol(0, props.cidmd.md.mediaURL())}\n          mimeType={props.cidmd.md.mimeType()}\n        />\n      </Card>\n    </Link>\n  );\n}\n","import React from 'react'\nimport { Button, Elevation, FileInput, Card} from \"@blueprintjs/core\"\nimport { getTypeFromMimeType, Metadata} from './lib/metadata'\nimport { putToIPFS } from './lib/ipfs'\nimport { MediaDisplay } from './MediaDisplay'\n\ntype UploaderProps = {\n    activeConfig: number\n}\n\nexport function Uploader(props: UploaderProps) {\n\n    const [meta, setMeta]               = React.useState(new Metadata())\n    const [title, setTitle]             = React.useState<string>();\n    const [loading, setLoading]         = React.useState(false)\n    const [fileObj, setFileObj]         = React.useState<File>();\n    const [mediaSrc, setMediaSrc]       = React.useState<string>();\n    const [mimeType, setMimeType]       = React.useState<string>();\n\n    function setFile(file: File) {\n        setFileObj(file)\n\n        const reader = new FileReader();\n        reader.onload = (e: any) => {  setMediaSrc(e.target.result) }\n        reader.readAsDataURL(file);\n\n        setMimeType(file.type)\n        setTitle(file.name)\n\n        setMeta((meta)=>{\n            const metaObj = {\n                ...meta,\n                properties:{...meta.properties, size:file.size, title:file.name}\n            }\n\n            const mediaType = getTypeFromMimeType(file.type)\n            switch(mediaType){\n                case 'audio':\n                    metaObj.animation_url = file.name\n                    metaObj.animation_url_mimetype = file.type\n                    break;\n                case 'video':\n                    metaObj.animation_url = file.name\n                    metaObj.animation_url_mimetype = file.type\n                    break;\n                case 'image':\n                    metaObj.image = file.name\n                    metaObj.image_mimetype = file.type\n                    break;\n            }\n\n            return new Metadata(metaObj)\n        })\n    }\n\n    async function uploadMedia() {\n        setLoading(true) \n\n        const md = new Metadata({\n            ...meta,\n            name: \"SXSW AlgoRanch NFT\",\n            unitName:\"sxsw-aus\",\n            description:\"NFT Minted SXSW 2022\",\n            decimals: 0,\n        }) \n        setMeta(md)\n\n        try {\n            await putToIPFS(props.activeConfig, fileObj, md)\n            setLoading(false)\n            window.location.reload()\n        } catch (error) {\n            console.error(error)\n            alert(\"Failed to upload image to ipfs :(\")\n            setLoading(false)\n            return\n        }\n    }\n\n    return (\n        <div className='container'>\n            <Card elevation={Elevation.TWO} className='mint-card' >\n                <UploadContainer mediaTitle={title} mimeType={mimeType} mediaSrc={mediaSrc} setFile={setFile} {...meta} />\n                <Button intent='success' style={{float:'right', margin:\"15px\"}} loading={loading} onClick={uploadMedia}>Upload</Button>\n            </Card>\n        </div>\n    )\n\n}\n\ntype UploaderContainerProps = {\n    mediaTitle: string | undefined\n    mediaSrc: string | undefined\n    mimeType: string | undefined\n    setFile(f: File): void\n};\n\nfunction UploadContainer(props: UploaderContainerProps) {\n    function captureFile(event: any) {\n        event.stopPropagation()\n        event.preventDefault()\n        props.setFile(event.target.files.item(0))\n    }\n\n    if (props.mediaSrc === undefined || props.mediaSrc === \"\" ) return (\n        <div className='container'>\n            <div className='content content-piece' >\n                <FileInput large={true} disabled={false} text=\"Choose file...\" onInputChange={captureFile} />\n            </div>\n        </div>\n    )\n\n    return (\n        <div className='container' >\n            <div className='content content-piece'>\n                <MediaDisplay title={props.mediaTitle} mimeType={props.mimeType} mediaSrc={props.mediaSrc} />\n            </div>\n        </div>\n    )\n}","import { SessionWallet } from 'algorand-session-wallet'\nimport QrScanner from \"qr-scanner\";\nimport {useParams} from 'react-router-dom'\nimport React from 'react'\nimport { NFT, resolveProtocol} from './lib/nft'\nimport { Metadata } from './lib/metadata'\nimport { getIpfsUrlFromCID, getMetaFromIpfs } from './lib/ipfs'\nimport {fundAccount, xferAsset} from './lib/algorand'\nimport { Button, Card, Dialog, Elevation } from '@blueprintjs/core'\nimport QRCode from \"react-qr-code\";\nimport algosdk, {secretKeyToMnemonic } from 'algosdk'\nimport { DIALOG_BODY, DIALOG_FOOTER } from '@blueprintjs/core/lib/esm/common/classes'\nimport { MediaDisplay } from './MediaDisplay';\n\nQrScanner.WORKER_PATH = \"/qr-scanner-worker.min.js\"\n\nexport type MinterProps = {\n    activeConfig: number \n    sw: SessionWallet\n}\n\nexport function Minter(props: MinterProps){\n    // Mint the chosen nft image with our minting account\n    const {cid} = useParams()\n    const [md, setMd] = React.useState(new Metadata({}))\n    const [importingAccount, setImportingAccount] = React.useState(undefined)\n    const [nft, setNFT] = React.useState(undefined)\n    const [fundLoading, setFundLoading] = React.useState(false)\n    const [loading, setLoading] = React.useState(false)\n    const [popupOpen,setPopupOpen] = React.useState(false)\n\n    const [createdId, setCreatedId] = React.useState(0)\n\n    React.useEffect(()=>{\n        if(md._raw === undefined)\n            getMetaFromIpfs(getIpfsUrlFromCID(props.activeConfig, cid)).then((md)=>{\n                setMd(md)\n            })\n    }, [props.activeConfig, cid, md])\n\n    async function mintOnly(){\n        // Create ASA with our user\n        setLoading(true)\n        const result = await NFT.create(props.sw.wallet, props.activeConfig,  md, cid)\n        setNFT(result)\n        setCreatedId(result.id())\n    }\n\n    async function handleScannedAccount(addr: string){\n        // Fires after successful scan of addr\n        await xferAsset(props.sw.wallet, props.activeConfig, addr, createdId)\n\n        setCreatedId(0)\n        setLoading(false)\n    }\n\n    async function mintAndCreate(){\n        // Create account\n        setLoading(true)\n        const acct = algosdk.generateAccount()\n        setImportingAccount(acct)\n    }\n\n    function cancelCreate() { \n        setLoading(false)\n        setImportingAccount(undefined) \n    }\n\n    async function continueCreate() {\n        // Create ASA\n        const result = await NFT.create(props.sw.wallet, props.activeConfig,  md, cid)\n        setNFT(result)\n        setPopupOpen(true)\n    }\n\n    async function fundIt(){\n        // User has scanned it, issue grouped transactions\n        setFundLoading(true)\n        \n        await fundAccount(props.sw.wallet, props.activeConfig, importingAccount, nft.id())\n        // Unset\n        setImportingAccount(undefined)\n        setFundLoading(false)\n        setLoading(false)\n        window.location.href=\"/NFTBooth\"\n    }\n\n    return (\n        <div className='container'>\n            <NFTCard loading={loading} cid={cid} md={md} mintOnly={mintOnly} mintAndCreate={mintAndCreate}></NFTCard>\n            <AccountImporter importingAccount={importingAccount} cancelCreate={cancelCreate} continueCreate={continueCreate}/>\n            <AddressReader  optIn={createdId} handleScanned={handleScannedAccount}></AddressReader>\n            <Dialog isOpen={popupOpen} >\n                <div className={DIALOG_BODY}>\n                    <div className='container'>\n                        <Button loading={fundLoading} intent='success' onClick={fundIt}>Fund it!</Button>\n                    </div>\n                </div>\n            </Dialog>\n        </div>\n    )\n}\n\ninterface NFTCardProps {\n    cid: string\n    md: Metadata\n    loading: boolean\n    mintOnly()\n    mintAndCreate()\n}\n\nfunction NFTCard(props: NFTCardProps) {\n    return (\n        <Card elevation={Elevation.THREE} >\n            <MediaDisplay \n                title={props.md.title()}\n                mediaSrc={resolveProtocol(0, props.md.mediaURL())} \n                mimeType={props.md.mimeType()} \n            />\n            <div className='container'>\n                <Button loading={props.loading} icon='clean' intent='success' onClick={props.mintAndCreate}>Mint</Button>\n            </div>\n        </Card>\n    )\n}\n\ninterface AccountImporterProps {\n    importingAccount: algosdk.Account \n    continueCreate()\n    cancelCreate()\n}\n\nfunction AccountImporter(props: AccountImporterProps) {\n    const [isOpen, setIsOpen] = React.useState(false)\n    const [mn, setMn]  = React.useState(\"\")\n\n    const ic = props.importingAccount\n    React.useEffect(()=>{\n        if(ic !== undefined){\n            setMn(JSON.stringify({\n                \"version\":\"1.0\", \n                \"mnemonic\":secretKeyToMnemonic(ic.sk)\n            }))\n            setIsOpen(true)\n        }\n    }, [ic])\n\n    function cancelCreate(){\n        setIsOpen(false)\n        props.cancelCreate()\n    }\n    function continueCreate(){\n        setIsOpen(false)\n        props.continueCreate()\n    }\n\n    return (\n        <Dialog isOpen={isOpen} className='content' >\n            <div className={DIALOG_BODY} >\n                <QRCode  value={mn} />\n            </div>\n            <div className={DIALOG_FOOTER} >\n                <div className='container'>\n                    <Button style={{margin:\"0px 10px\"}} intent='danger' onClick={cancelCreate}>Cancel</Button>\n                    <Button style={{margin:\"0px 10px\"}} intent='success' onClick={continueCreate}>Ready!</Button>\n                </div>\n            </div>\n        </Dialog>\n    )\n}\n\nexport interface AddressReaderProps {\n    optIn: number \n    handleScanned(addr: string): void\n}\n\nexport function AddressReader(props: AddressReaderProps) {\n    const vref = React.useRef<HTMLVideoElement>(null)\n    const [scanner, setScanner] = React.useState<QrScanner | undefined>(undefined)\n    const [isOpen, setIsOpen] = React.useState(false)\n\n    const open = props.optIn !== undefined && props.optIn>0\n    React.useEffect(()=>{\n        setIsOpen(open)\n        scanner?.stop()\n        scanner?.start()\n    }, [scanner, open])\n\n    let seen = \"\"\n    function initCam(){\n        function handleScanned(data: string){\n            if(seen === data) return\n\n            scanner?.stop()\n            vref.current = null\n            setScanner(undefined)\n            setIsOpen(false)\n            seen = data\n            props.handleScanned(data)\n        }\n\n        if(vref.current !== null && scanner === undefined)\n           setScanner(new QrScanner(vref.current,handleScanned))\n    }\n\n    return (\n        <Dialog isOpen={isOpen} onOpened={initCam}>\n            <div className={DIALOG_BODY}>\n                <h3>Please Opt into Asset ID {props.optIn}</h3>\n                <div className='scanner-container'>\n                    <video style={{width: '100%'}} ref={vref}></video>\n                </div>\n            </div>\n        </Dialog>\n    )\n}","import * as React from 'react'\n\nimport { SessionWallet, allowedWallets } from 'algorand-session-wallet'\n\nimport { Dialog, Button, Classes, HTMLSelect, Intent } from '@blueprintjs/core'\nimport { IconName } from '@blueprintjs/icons'\n\n\ntype AlgorandWalletConnectorProps = {\n    darkMode: boolean\n    connected: boolean\n    accts: string[]\n    sessionWallet: SessionWallet\n    updateWallet(sw: SessionWallet): void\n}\n\nexport default function AlgorandWalletConnector(props:AlgorandWalletConnectorProps)  {\n\n    const [selectorOpen, setSelectorOpen] = React.useState(false)\n\n    const {sessionWallet,updateWallet} = props\n    React.useEffect(()=>{\n        if(sessionWallet.connected()) return\n\n        let interval: any\n        sessionWallet.connect().then((success)=>{\n            if(!success) return\n\n            // Check every 500ms to see if we've connected then kill the interval\n            // This is most useful in the case of walletconnect where it may be several \n            // seconds before the user connects\n            interval = setInterval(()=>{\n                if(sessionWallet.connected()) {\n                    clearInterval(interval)\n                    updateWallet(sessionWallet)\n                }\n            }, 500)\n\n        })\n\n        return ()=>{ clearInterval(interval) }\n\n    }, [sessionWallet, updateWallet])\n\n\n    function disconnectWallet() { \n        props.sessionWallet.disconnect()\n        props.updateWallet(new SessionWallet(props.sessionWallet.network, props.sessionWallet.permissionCallback)) \n    }\n\n    function handleDisplayWalletSelection() { setSelectorOpen(true) }\n\n    async function handleSelectedWallet(e: any) {\n        const choice = e.currentTarget.id\n\n        if(!(choice in allowedWallets)) {\n            if(props.sessionWallet.wallet !== undefined) props.sessionWallet.disconnect()\n            return setSelectorOpen(false)\n        }\n\n        const sw = new SessionWallet(props.sessionWallet.network, props.sessionWallet.permissionCallback, choice)\n\n        if(!await sw.connect()) {\n            sw.disconnect()\n        }\n\n        props.updateWallet(sw)\n\n        setSelectorOpen(false)\n    }\n\n    function handleChangeAccount(e: any) {\n        props.sessionWallet.setAccountIndex(parseInt(e.target.value))\n        props.updateWallet(props.sessionWallet)\n    }\n\n    const walletOptions = []\n    for(const [k,v] of Object.entries(allowedWallets)){\n        walletOptions.push((\n        <li key={k}>\n            <Button id={k}\n                large={true} \n                fill={true} \n                minimal={true} \n                outlined={true} \n                onClick={handleSelectedWallet}\n                > \n                <div className='wallet-option'>\n                    <img alt='wallet-branding' className='wallet-branding' src={  v.img(props.darkMode)} />\n                    <h5>{v.displayName()}</h5>\n                </div>\n                </Button>\n        </li>\n        ))\n    }\n\n    if (!props.connected) return (\n        <div>\n            <Button\n                minimal={true}\n                rightIcon='selection'\n                intent='warning'\n                outlined={true}\n                onClick={handleDisplayWalletSelection}>Connect Wallet</Button>\n\n            <Dialog isOpen={selectorOpen} title='Select Wallet' onClose={handleSelectedWallet} >\n                <div className={Classes.DIALOG_BODY}>\n                    <ul className='wallet-option-list'>\n                        {walletOptions}\n                    </ul>\n                </div>\n            </Dialog>\n        </div>\n    )\n\n\n    const addr_list = props.accts.map((addr, idx) => {\n        return (<option value={idx} key={idx}> {addr.substr(0, 8)}...  </option>)\n    })\n\n    const iconprops = { \n        icon: 'symbol-circle' as IconName, \n        intent: 'success'  as Intent\n    }\n\n    return (\n        <div>\n            <HTMLSelect \n                onChange={handleChangeAccount} \n                minimal={true} \n                iconProps={iconprops} \n                defaultValue={props.sessionWallet.accountIndex()} >\n                {addr_list}\n            </HTMLSelect>\n            <Button icon='log-out' minimal={true} onClick={disconnectWallet} ></Button>\n        </div>\n    )\n}","import Picker from './Picker'\nimport './index.css';\nimport { Button, Alignment, Navbar } from '@blueprintjs/core';\nimport { SessionWallet } from 'algorand-session-wallet';\nimport {Uploader} from './Uploader'\nimport React from 'react';\nimport {Minter} from './Minter';\nimport AlgorandWalletConnector from './AlgorandWalletConnector'\nimport { conf, sessionGetActiveConf } from './lib/config';\n\nimport {\n  HashRouter as Router,\n  Link,\n  Switch,\n  Route,\n} from 'react-router-dom'\n\n\ntype AppProps = {\n  history: History,\n}\n\nfunction App(props: AppProps) {\n\n  const activeConf = sessionGetActiveConf()\n\n  const sw = new SessionWallet(conf[activeConf].network)\n\n\n  const [sessionWallet, setSessionWallet] =  React.useState(sw)\n  const [accts, setAccounts] = React.useState(sw.accountList())\n  const [connected, setConnected] = React.useState(sw.connected())\n\n  function updateWallet(sw: SessionWallet){ \n    setSessionWallet(sw)\n    setAccounts(sw.accountList())\n    setConnected(sw.connected())\n  }\n\n  return (\n    <Router >\n      <div className=\"App\">\n        <Navbar>\n        <Navbar.Group align={Alignment.LEFT}>\n          <Navbar.Heading>Algorand NFT Minter</Navbar.Heading>\n          <Navbar.Divider />\n          <Link to='/'><Button minimal={true} icon='search'>Choose</Button></Link>\n          <Link to='/upload'><Button minimal={true} icon='upload'>Upload</Button></Link>\n        </Navbar.Group>\n        <Navbar.Group  align={Alignment.RIGHT}>\n          <AlgorandWalletConnector  \n            darkMode={false}\n            sessionWallet={sessionWallet}\n            accts={accts}\n            connected={connected} \n            updateWallet={updateWallet}\n          />\n\n        </Navbar.Group>\n        </Navbar>\n        <Switch>\n          <Route exact path=\"/\" children={<Picker  activeConfig={activeConf} sw={sessionWallet}></Picker>} />\n          <Route path=\"/mint/:cid\" children={ <Minter  activeConfig={activeConf} sw={sessionWallet}></Minter> }/>\n          <Route exact path=\"/upload\" children={ <Uploader  activeConfig={activeConf} ></Uploader> }/>\n        </Switch>\n      </div>\n    </Router>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\n\n\nimport {createBrowserHistory} from \"history\"\n\nconst history = createBrowserHistory();\n\nReactDOM.render(\n  <React.StrictMode>\n    <App history={history}  />\n  </React.StrictMode>,\n  document.getElementById('root')\n);","type Config = {\n    network: string;       // The network to use for creating nfts\n    storageToken: string;  // The token provided by web3.storage\n    ipfsGateway: string;   // The IPFS gateway url for retrieving files\n    algod: string          // The Algod api url to use\n    blockExplorer: string; // The Block Explorer to allow linking out to\n}\n\nexport const conf = require(\"../config.json\") as Config[];\n\nexport function getAddrUrl(idx: number, addr: string): string {\n    return conf[idx].blockExplorer + \"address/\" + addr\n}\nexport function getAsaUrl(idx: number, id: number): string {\n    return conf[idx].blockExplorer + \"asset/\" + id \n}\n\nconst activeConfKey = \"active-conf\"\nexport function sessionGetActiveConf(): number {\n    const ac = sessionStorage.getItem(activeConfKey)\n    if(ac === undefined || ac === null) return 0\n    return parseInt(ac)\n}\n\nexport function sessionSetActiveConf(ac: number)  {\n    sessionStorage.setItem(activeConfKey, ac.toString())\n}\n","import { Wallet } from \"algorand-session-wallet\";\nimport algosdk, {\n  Algodv2,\n  waitForConfirmation,\n  makeAssetCreateTxnWithSuggestedParamsFromObject,\n  makeAssetTransferTxnWithSuggestedParamsFromObject,\n  makePaymentTxnWithSuggestedParamsFromObject,\n} from \"algosdk\";\nimport { NFT } from \"./nft\";\nimport { Metadata } from \"./metadata\";\nimport { conf } from \"./config\";\n\nfunction getClient(activeConf: number): Algodv2 {\n  return new algosdk.Algodv2(\"\", conf[activeConf].algod, \"\");\n}\n\nexport async function createToken(\n  wallet: Wallet,\n  activeConf: number,\n  url: string,\n  md: Metadata\n): Promise<number> {\n  const addr = wallet.getDefaultAccount();\n  const suggested = await getSuggested(activeConf, 1000);\n\n  const create_txn = makeAssetCreateTxnWithSuggestedParamsFromObject({\n    from: addr,\n    assetName: md.name,\n    unitName: md.unitName,\n    assetURL: url,\n    assetMetadataHash: md.toHash(),\n    manager: addr,\n    total: 1,\n    decimals: 0,\n    defaultFrozen: false,\n    suggestedParams: suggested,\n  });\n\n  const [create_txn_s]  = await wallet.signTxn([create_txn])\n  const result = await sendWait(activeConf, [create_txn_s])\n  return result['asset-index']\n}\n\nexport async function fundAccount(\n  wallet: Wallet,\n  activeConf: number,\n  acct: algosdk.Account,\n  id: number\n) {\n  const addr = wallet.getDefaultAccount();\n  const suggested = await getSuggested(activeConf, 100);\n\n  const fund_txn = makePaymentTxnWithSuggestedParamsFromObject({\n    from: addr,\n    to: acct.addr,\n    amount: 3e5,\n    suggestedParams: suggested,\n  });\n\n  const optin_txn = makeAssetTransferTxnWithSuggestedParamsFromObject({\n    from: acct.addr,\n    to: acct.addr,\n    assetIndex: id,\n    amount: 0,\n    suggestedParams: suggested,\n  });\n\n  const xfer_txn = makeAssetTransferTxnWithSuggestedParamsFromObject({\n    from: addr,\n    to: acct.addr,\n    assetIndex: id,\n    amount: 1,\n    suggestedParams: suggested,\n  });\n\n\n  const grouped = [fund_txn, optin_txn, xfer_txn];\n  algosdk.assignGroupID(grouped);\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  const [fund_txn_s, _, xfer_txn_s] = await wallet.signTxn(grouped);\n  const optin_txn_s = algosdk.signTransaction(optin_txn, acct.sk);\n  await sendWait(activeConf, [fund_txn_s, optin_txn_s, xfer_txn_s]);\n}\n\nexport async function xferAsset(\n  wallet: Wallet,\n  activeConf: number,\n  rx: string,\n  id: number\n) {\n  const addr = wallet.getDefaultAccount();\n  const suggested = await getSuggested(activeConf, 100);\n\n  const xfer_txn = makeAssetTransferTxnWithSuggestedParamsFromObject({\n    from: addr,\n    to: rx,\n    assetIndex: id,\n    amount: 1,\n    suggestedParams: suggested,\n  });\n\n  const [create_txn_s] = await wallet.signTxn([xfer_txn]);\n  await sendWait(activeConf, [create_txn_s]);\n}\n\nexport async function getSuggested(activeConf: number, rounds: number) {\n  const txParams = await getClient(activeConf).getTransactionParams().do();\n  return { ...txParams, lastRound: txParams[\"firstRound\"] + rounds };\n}\n\nexport async function getToken(\n  activeConf: number,\n  assetId: number\n): Promise<any> {\n  return await getClient(activeConf).getAssetByID(assetId).do();\n}\n\nexport async function getCollection(\n  activeConf: number,\n  address: string\n): Promise<any[]> {\n  const results = await getClient(activeConf).accountInformation(address).do();\n\n  const plist = [];\n  for (const a in results[\"assets\"]) {\n    if (results[\"assets\"][a][\"amount\"] > 0)\n      plist.push(getToken(activeConf, results[\"assets\"][a][\"asset-id\"]));\n  }\n\n  const assets = await Promise.all(plist);\n  const collectionRequests = assets.map((a) => {\n    return NFT.fromToken(activeConf, a);\n  });\n  return Promise.all(collectionRequests);\n}\n\nexport async function sendWait(\n  activeConf: number,\n  signed: any[]\n): Promise<any> {\n  const client = getClient(activeConf);\n  try {\n    const { txId } = await client\n      .sendRawTransaction( signed.map((t) => { return t.blob; }))\n      .do();\n    const result = await waitForConfirmation(client, txId, 3);\n    return result;\n  } catch (error) {\n    console.error(error);\n  }\n\n  return undefined;\n}"],"sourceRoot":""}