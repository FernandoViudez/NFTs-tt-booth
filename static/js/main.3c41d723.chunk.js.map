{"version":3,"sources":["lib/metadata.ts","lib/nft.ts","MediaDisplay.tsx","Picker.tsx","Uploader.tsx","Minter.tsx","AlgorandWalletConnector.tsx","App.tsx","index.tsx","lib/ipfs.ts","lib/config.ts","lib/algorand.ts"],"names":["getTypeFromMimeType","filetype","split","type","omitRawAndEmpty","k","v","Metadata","args","_raw","undefined","name","description","image","decimals","unitName","image_integrity","image_mimetype","background_color","external_url","external_url_integrity","external_url_mimetype","animation_url","animation_url_integrity","animation_url_mimetype","extra_metadata","localization","properties","Object","assign","this","fmt","hasOwnProperty","toString","hash","sha256","create","update","Uint8Array","digest","md_blob","Blob","JSON_TYPE","File","METADATA_FILE","title","JSON","stringify","parse","mimeType","t","url","ARC3_URL_SUFFIX","ipfsURL","cid","resolveProtocol","activeConf","endsWith","slice","length","chunks","conf","ipfsGateway","mediaIntegrity","file","a","arrayBuffer","buff","bytes","Buffer","from","Token","id","metadataHash","total","creator","manager","reserve","clawback","freeze","defaultFrozen","p","params","index","NFT","md","token","urlMimeType","metadata","valid","mediaURL","substring","wallet","createToken","asset_id","fromAssetId","assetId","getToken","fromToken","fromParams","getMimeTypeFromIpfs","getMetaFromIpfs","MediaDisplay","props","media","controls","src","mediaSrc","alt","className","Picker","React","useState","options","setOptions","initialized","setInitialized","useEffect","listRecentFiles","activeConfig","then","opts","md_promises","opt","push","getIpfsUrlFromCID","Promise","all","arr","filtered","idx","cards","map","option","DisplayCard","cidmd","to","elevation","Elevation","TWO","Uploader","meta","setMeta","setTitle","loading","setLoading","fileObj","setFileObj","setMediaSrc","setMimeType","putToIPFS","window","location","reload","console","error","alert","UploadContainer","mediaTitle","setFile","reader","FileReader","onload","e","target","result","readAsDataURL","metaObj","size","intent","style","float","margin","onClick","large","disabled","text","onInputChange","event","stopPropagation","preventDefault","files","item","Minter","useParams","setMd","importingAccount","setImportingAccount","nft","setNFT","fundLoading","setFundLoading","popupOpen","setPopupOpen","createdId","setCreatedId","sw","addr","xferAsset","acct","algosdk","generateAccount","fundAccount","href","NFTCard","mintOnly","mintAndCreate","AccountImporter","cancelCreate","continueCreate","AddressReader","optIn","handleScanned","isOpen","DIALOG_BODY","THREE","icon","setIsOpen","mn","setMn","ic","secretKeyToMnemonic","sk","value","DIALOG_FOOTER","vref","useRef","scanner","setScanner","open","stop","start","seen","onOpened","current","QrScanner","data","width","ref","WORKER_PATH","AlgorandWalletConnector","selectorOpen","setSelectorOpen","sessionWallet","updateWallet","handleSelectedWallet","choice","currentTarget","allowedWallets","disconnect","SessionWallet","network","permissionCallback","connect","interval","connected","success","setInterval","clearInterval","walletOptions","entries","fill","minimal","outlined","img","darkMode","displayName","rightIcon","onClose","Classes","addr_list","accts","substr","onChange","setAccountIndex","parseInt","iconProps","defaultValue","accountIndex","App","sessionGetActiveConf","setSessionWallet","accountList","setAccounts","setConnected","Group","align","Alignment","LEFT","Heading","Divider","RIGHT","exact","path","children","history","createBrowserHistory","ReactDOM","render","StrictMode","document","getElementById","storageClient","getStorageClient","Web3Storage","endpoint","storage","put","wrapWithDirectory","mediaAdded","integ","mdc","mediaType","mdobj","toFile","ms_threshold","w3s","list","maxResults","upload","req","Request","method","fetch","resp","headers","get","blob","body","parsed","require","activeConfKey","ac","sessionStorage","getItem","getClient","Algodv2","algod","getDefaultAccount","getSuggested","suggested","create_txn","makeAssetCreateTxnWithSuggestedParamsFromObject","assetName","assetURL","assetMetadataHash","toHash","suggestedParams","signTxn","create_txn_s","sendWait","fund_txn","makePaymentTxnWithSuggestedParamsFromObject","amount","optin_txn","makeAssetTransferTxnWithSuggestedParamsFromObject","assetIndex","xfer_txn","grouped","assignGroupID","fund_txn_s","xfer_txn_s","optin_txn_s","signTransaction","rx","rounds","getTransactionParams","do","txParams","lastRound","getAssetByID","signed","client","sendRawTransaction","txId","waitForConfirmation"],"mappings":"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","file":"static/js/main.3c41d723.chunk.js","sourcesContent":["import {Token, JSON_TYPE, METADATA_FILE} from './nft'\nimport { sha256 } from 'js-sha256'\n\nexport type Properties = {\n    [key: string]: string | number\n}\n\nexport type LocalizationIntegrity = {\n    [key: string]: string \n}\n\nexport type Localization = {\n    uri: string \n    default: string \n    locales: string[] \n    integrity?: LocalizationIntegrity\n}\n\n// Just takes the first chunk of the mimetype (the type)\nexport function getTypeFromMimeType(filetype: string): string {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const [type, _] = filetype.split(\"/\")\n    return type\n}\n\nfunction omitRawAndEmpty(k,v){\n    if(k === \"_raw\") return undefined;\n    if(v === \"\") return undefined;\n    return v\n}\n\nexport class Metadata {\n    _raw: string = undefined\n\n    name: string = \"\"\n    description: string = \"\"\n\n    image: string = \"\"\n    decimals?: number = 0\n    unitName?: string = \"\"\n    image_integrity?: string = \"\"\n    image_mimetype?: string = \"\"\n\n    background_color?: string = \"\"\n    external_url?: string = \"\"\n    external_url_integrity?: string = \"\"\n    external_url_mimetype?: string = \"\"\n\n    animation_url?: string = \"\"\n    animation_url_integrity?: string = \"\"\n    animation_url_mimetype?: string = \"\"\n\n    extra_metadata?: string = \"\"\n\n    localization?: Localization\n\n    properties?: Properties\n\n    constructor(args: any = {}) { Object.assign(this, args) }\n\n    toHash(fmt: Boolean = false): Uint8Array {\n        if(this.hasOwnProperty(\"extra_metadata\")){\n            //TODO\n            //am = SHA-512/256(\"arc0003/am\" || SHA-512/256(\"arc0003/amj\" || content of JSON metadata file) || e)\n        }\n\n        if(this._raw === undefined) \n            this._raw = this.toString(false)\n\n        const hash = sha256.create();\n        fmt ? hash.update(this.toString(false)):hash.update(this._raw);\n        return new Uint8Array(hash.digest())\n    }\n\n    valid(): boolean {\n        return this.image !== \"\"\n    }\n\n    toFile(): File {\n        const md_blob = new Blob([this.toString()], { type: JSON_TYPE })\n        return new File([md_blob], METADATA_FILE)\n    }\n\n    title(): string {\n        if(this.properties !== undefined && 'title' in this.properties) return this.properties.title.toString()\n        return this.name\n    }\n\n    toString(fmt: Boolean = false): string {\n        if(this._raw === undefined) this._raw = JSON.stringify({...this}, omitRawAndEmpty)\n        return JSON.stringify(JSON.parse(this._raw) , omitRawAndEmpty, fmt?2:0)\n    }\n\n\n    mimeType(): string {\n        if(this.animation_url !== \"\") return this.animation_url_mimetype;\n        if(this.external_url_mimetype !== \"\") return this.external_url_mimetype;\n        return this.image_mimetype\n    }\n\n    mediaType(): string {\n        return getTypeFromMimeType(this.mimeType())\n    }\n\n    mediaURL(): string {\n        if(this.animation_url !== \"\") {\n            return this.animation_url\n        }\n        return this.image\n    }\n\n\n    static fromToken(t: Token){\n        return new Metadata({name:t.name, image: t.url, decimals: t.decimals })\n    }\n}\n","import { createToken, getToken } from \"./algorand\";\nimport { getMimeTypeFromIpfs, getMetaFromIpfs } from \"./ipfs\";\nimport { sha256 } from \"js-sha256\";\nimport { Wallet } from \"algorand-session-wallet\";\nimport { conf } from \"./config\";\nimport { Metadata } from \"./metadata\";\n\n/*\n\nThe following is a class and metadata type to support the ARC-0003 standard \nset forth by the Algorand Foundation and Community\n\nhttps://github.com/algorandfoundation/ARCs/blob/main/ARCs/arc-0003.md\n\n*/\n\nexport const ARC3_NAME_SUFFIX = \"@arc3\";\nexport const ARC3_URL_SUFFIX = \"#arc3\";\nexport const METADATA_FILE = \"metadata.json\";\nexport const JSON_TYPE = \"application/json\";\n\nexport function asaURL(cid: string): string {\n  return ipfsURL(cid) + ARC3_URL_SUFFIX;\n}\nexport function ipfsURL(cid: string): string {\n  return \"ipfs://\" + cid;\n}\nexport function fileURL(activeConf: number, cid: string, name: string): string {\n  return conf[activeConf].ipfsGateway + cid + \"/\" + name;\n}\n\nexport function resolveProtocol(activeConf: number, url: string): string {\n  if (url.endsWith(ARC3_URL_SUFFIX))\n    url = url.slice(0, url.length - ARC3_URL_SUFFIX.length);\n\n  const chunks = url.split(\"://\");\n\n  // No protocol specified, give up\n  if (chunks.length < 2) return url;\n\n  //Switch on the protocol\n  switch (chunks[0]) {\n    case \"ipfs\": //Its ipfs, use the configured gateway\n      return conf[activeConf].ipfsGateway + chunks[1];\n    case \"https\": //Its already http, just return it\n      return url;\n    // TODO: Future options may include arweave or algorand\n  }\n\n  return url;\n}\n\nexport async function mediaIntegrity(file: File): Promise<string> {\n  const buff = await file.arrayBuffer();\n  const bytes = new Uint8Array(buff);\n  const hash = new Uint8Array(sha256.digest(bytes));\n  return \"sha256-\" + Buffer.from(hash).toString(\"base64\");\n}\n\nexport class Token {\n  id: number;\n\n  name: string;\n  unitName: string;\n  url: string;\n\n  metadataHash: string;\n\n  total: number;\n  decimals: number;\n\n  creator: string;\n\n  manager: string;\n  reserve: string;\n  clawback: string;\n  freeze: string;\n\n  defaultFrozen: boolean;\n\n  constructor(t: any) {\n    this.id = t.id || 0;\n    this.name = t.name || \"\";\n    this.unitName = t.unitName || \"\";\n    this.url = t.url || \"\";\n\n    this.metadataHash = t.metadataHash || \"\";\n\n    this.total = t.total || 0;\n    this.decimals = t.decimals || 0;\n\n    this.creator = t.creator || \"\";\n\n    this.manager = t.manager || \"\";\n    this.reserve = t.reserve || \"\";\n    this.clawback = t.clawback || \"\";\n    this.freeze = t.freeze || \"\";\n\n    this.defaultFrozen = t.defaultFrozen || false;\n  }\n\n  static fromParams(t: any): Token {\n    const p = t.params;\n    return new Token({\n      id: t.index,\n      name: p.name || \"\",\n      unitName: p[\"unit-name\"] || \"\",\n      url: p.url || \"\",\n      metadataHash: p[\"metadata-hash\"] || \"\",\n      total: p.total || 0,\n      decimals: p.decimals || 0,\n      creator: p.creator || \"\",\n      manager: p.manager || \"\",\n      reserve: p.reserve || \"\",\n      clawback: p.clawback || \"\",\n      freeze: p.freeze || \"\",\n      defaultFrozen: p[\"default-frozen\"] || false,\n    }) as Token;\n  }\n\n  valid(): boolean {\n    return this.id > 0 && this.total > 0 && this.url !== \"\";\n  }\n}\n\nexport class NFT {\n  token: Token = new Token({});\n  metadata: Metadata = new Metadata();\n\n  urlMimeType: string;\n\n  constructor(md: Metadata, token?: Token, urlMimeType?: string) {\n    this.metadata = md;\n    this.token = token;\n    this.urlMimeType = urlMimeType;\n  }\n\n  static async create(\n    wallet: Wallet,\n    activeConf: number,\n    md: Metadata,\n    cid: string\n  ): Promise<NFT> {\n    const asset_id = await createToken(wallet, activeConf, ipfsURL(cid), md);\n    return await NFT.fromAssetId(activeConf, asset_id);\n  }\n\n  static async fromAssetId(activeConf: number, assetId: number): Promise<NFT> {\n    return NFT.fromToken(activeConf, await getToken(activeConf, assetId));\n  }\n\n  static async fromToken(activeConf: number, t: any): Promise<NFT> {\n    const token = Token.fromParams(t);\n    const url = resolveProtocol(activeConf, token.url);\n\n    //TODO: provide getters for other storage options\n    // arweave? note field?\n\n    try {\n      const urlMimeType = await getMimeTypeFromIpfs(url);\n\n      switch (urlMimeType) {\n        case JSON_TYPE:\n          return new NFT(await getMetaFromIpfs(url), token, urlMimeType);\n      }\n\n      return new NFT(Metadata.fromToken(token), token, urlMimeType);\n    } catch (error) {\n      return new NFT(new Metadata(), token);\n    }\n  }\n\n  valid(): boolean {\n    return this.token.valid() && this.metadata.valid();\n  }\n\n  name(): string {\n    if (this.metadata.valid()) {\n      return this.metadata.name;\n    }\n    if (this.token.valid()) {\n      return this.token.name;\n    }\n    return \"\";\n  }\n\n  id(): number {\n    return this.token.valid() ? this.token.id : 0;\n  }\n\n  mediaURL(activeConf: number): string {\n    if (!this.valid()) return \"https://dummyimage.com/640x360/fff/aaa\";\n\n    // Try to resolve the protocol, if one is set\n    const url = resolveProtocol(activeConf, this.metadata.mediaURL());\n\n    // If the url is different, we resolved it correctly\n    if (url !== this.metadata.mediaURL()) return url;\n\n    // It may be a relative url stored within the same directory as the metadata file\n    // Lop off the METADATA_FILE bit and append image path\n    if (this.token.url.endsWith(METADATA_FILE)) {\n      const dir = this.token.url.substring(\n        0,\n        this.token.url.length - METADATA_FILE.length\n      );\n      return resolveProtocol(activeConf, dir) + this.metadata.mediaURL();\n    }\n\n    // give up\n    return url;\n  }\n}\n","import { getTypeFromMimeType } from \"./lib/metadata\"\n\ntype MediaDisplayProps = {\n    title: string\n    mimeType: string\n    mediaSrc: string | undefined\n}\n\nexport function MediaDisplay(props: MediaDisplayProps){\n    const type = getTypeFromMimeType(props.mimeType)\n\n    let media = <div></div>\n    switch(type) {\n        case \"audio\":\n           media = (\n                <audio id=\"uploaded-media\" controls >\n                    <source src={props.mediaSrc} type={props.mimeType} />\n                </audio>\n            )\n            break;\n        case \"video\":\n            media = (\n                <video id=\"uploaded-media\" controls>\n                    <source src={props.mediaSrc} type={props.mimeType} />\n                </video>\n            )\n            break;\n        default:\n            media = (\n                <img id=\"uploaded-media\" alt=\"NFT\" src={props.mediaSrc} />\n            )\n    }\n\n    return (\n        <div className='media-display container'>\n\n            <h3>{props.title}</h3>\n\n            <div className='content' > \n                {media}\n            </div>\n        </div>\n    )\n}","import { Card, Elevation } from \"@blueprintjs/core\";\n\nimport {Link} from 'react-router-dom'\nimport React from \"react\";\nimport { Metadata } from \"./lib/metadata\";\nimport { resolveProtocol } from \"./lib/nft\";\nimport {\n  getIpfsUrlFromCID,\n  getMetaFromIpfs,\n  listRecentFiles,\n} from \"./lib/ipfs\";\nimport { SessionWallet } from \"algorand-session-wallet\";\nimport { MediaDisplay } from \"./MediaDisplay\";\n\ntype PickerProps = {\n  activeConfig: number;\n  sw: SessionWallet\n};\n\n// 2 hours\nconst MAX_DELTA = 60 * 60 * 4 * 1000;\n\n\nexport default function Picker(props: PickerProps) {\n  const [options, setOptions] = React.useState([]);\n  const [initialized, setInitialized] = React.useState(false);\n\n  // Look at recent\n  React.useEffect(() => {\n    if (initialized) return;\n\n    listRecentFiles(props.activeConfig, MAX_DELTA).then((opts) => {\n      const md_promises = [];\n      for (const opt of opts) {\n        //const opt = opts[idx];\n        md_promises.push(\n          getMetaFromIpfs(getIpfsUrlFromCID(props.activeConfig, opt.cid))\n        );\n      }\n\n      Promise.all(md_promises).then((arr) => {\n        const filtered = [];\n        for (const idx in arr) {\n          if (arr[idx].name !== \"\") filtered.push({\n              cid: opts[idx].cid,\n              md: arr[idx]\n            } as CIDMD);\n        }\n        setOptions(filtered);\n        setInitialized(true);\n      });\n    });\n  }, [props.activeConfig, initialized]);\n\n  const cards = initialized?options.map((option) => {\n    return <DisplayCard key={option.cid} cidmd={option} />;\n  }):[<h5 key='loading'>Loading...</h5>];\n\n  return (\n    <div className=\"container\">\n      <div className=\"content content-collection\">\n        {cards}\n      </div>\n    </div>\n  );\n}\n\ntype CIDMD = {\n    cid: string\n    md: Metadata\n}\n\ntype DisplayCardProps = {\n  cidmd: CIDMD;\n};\n\nfunction DisplayCard(props: DisplayCardProps) {\n  return (\n\n    <Link to={'/mint/'+props.cidmd.cid}>\n      <Card\n        className=\"content-collection-item\"\n        elevation={Elevation.TWO}\n      >\n              <MediaDisplay \n                title={props.cidmd.md.title()}\n                mediaSrc={resolveProtocol(0,props.cidmd.md.mediaURL())} \n                mimeType={props.cidmd.md.mimeType()} \n                />\n      </Card>\n    </Link>\n  );\n}\n","import React from 'react'\nimport { Button, Elevation, FileInput, Card} from \"@blueprintjs/core\"\nimport { getTypeFromMimeType, Metadata} from './lib/metadata'\nimport { putToIPFS } from './lib/ipfs'\nimport { MediaDisplay } from './MediaDisplay'\n\ntype UploaderProps = {\n    activeConfig: number\n}\n\nexport function Uploader(props: UploaderProps) {\n\n    const [meta, setMeta]               = React.useState(new Metadata())\n    const [title, setTitle]             = React.useState<string>();\n    const [loading, setLoading]         = React.useState(false)\n    const [fileObj, setFileObj]         = React.useState<File>();\n    const [mediaSrc, setMediaSrc]       = React.useState<string>();\n    const [mimeType, setMimeType]       = React.useState<string>();\n\n    function setFile(file: File) {\n        setFileObj(file)\n\n        const reader = new FileReader();\n        reader.onload = (e: any) => {  setMediaSrc(e.target.result) }\n        reader.readAsDataURL(file);\n\n        setMimeType(file.type)\n        setTitle(file.name)\n\n        setMeta((meta)=>{\n            const metaObj = {\n                ...meta,\n                properties:{...meta.properties, size:file.size, title:file.name}\n            }\n\n            const mediaType = getTypeFromMimeType(file.type)\n            switch(mediaType){\n                case 'audio':\n                    metaObj.animation_url = file.name\n                    metaObj.animation_url_mimetype = file.type\n                    break;\n                case 'video':\n                    metaObj.animation_url = file.name\n                    metaObj.animation_url_mimetype = file.type\n                    break;\n                case 'image':\n                    metaObj.image = file.name\n                    metaObj.image_mimetype = file.type\n                    break;\n            }\n\n            return new Metadata(metaObj)\n        })\n    }\n\n    async function uploadMedia() {\n        setLoading(true) \n\n        const md = new Metadata({\n            ...meta,\n            name: \"SXSW AlgoRanch NFT\",\n            unitName:\"sxsw-aus\",\n            description:\"NFT Minted SXSW 2022\",\n            decimals: 0,\n        }) \n        setMeta(md)\n\n        try {\n            await putToIPFS(props.activeConfig, fileObj, md)\n            setLoading(false)\n            window.location.reload()\n        } catch (error) {\n            console.error(error)\n            alert(\"Failed to upload image to ipfs :(\")\n            setLoading(false)\n            return\n        }\n    }\n\n    return (\n        <div className='container'>\n            <Card elevation={Elevation.TWO} className='mint-card' >\n                <UploadContainer mediaTitle={title} mimeType={mimeType} mediaSrc={mediaSrc} setFile={setFile} {...meta} />\n                <Button intent='success' style={{float:'right', margin:\"15px\"}} loading={loading} onClick={uploadMedia}>Upload</Button>\n            </Card>\n        </div>\n    )\n\n}\n\ntype UploaderContainerProps = {\n    mediaTitle: string | undefined\n    mediaSrc: string | undefined\n    mimeType: string | undefined\n    setFile(f: File): void\n};\n\nfunction UploadContainer(props: UploaderContainerProps) {\n    function captureFile(event: any) {\n        event.stopPropagation()\n        event.preventDefault()\n        props.setFile(event.target.files.item(0))\n    }\n\n    if (props.mediaSrc === undefined || props.mediaSrc === \"\" ) return (\n        <div className='container'>\n            <div className='content content-piece' >\n                <FileInput large={true} disabled={false} text=\"Choose file...\" onInputChange={captureFile} />\n            </div>\n        </div>\n    )\n\n    return (\n        <div className='container' >\n            <div className='content content-piece'>\n                <MediaDisplay title={props.mediaTitle} mimeType={props.mimeType} mediaSrc={props.mediaSrc} />\n            </div>\n        </div>\n    )\n}","import { SessionWallet } from 'algorand-session-wallet'\nimport QrScanner from \"qr-scanner\";\nimport {useParams} from 'react-router-dom'\nimport React from 'react'\nimport { NFT, resolveProtocol} from './lib/nft'\nimport { Metadata } from './lib/metadata'\nimport { getIpfsUrlFromCID, getMetaFromIpfs } from './lib/ipfs'\nimport {fundAccount, xferAsset} from './lib/algorand'\nimport { Button, Card, Dialog, Elevation } from '@blueprintjs/core'\nimport QRCode from \"react-qr-code\";\nimport algosdk, {secretKeyToMnemonic } from 'algosdk'\nimport { DIALOG_BODY, DIALOG_FOOTER } from '@blueprintjs/core/lib/esm/common/classes'\nimport { MediaDisplay } from './MediaDisplay';\n\nQrScanner.WORKER_PATH = \"/qr-scanner-worker.min.js\"\n\nexport type MinterProps = {\n    activeConfig: number \n    sw: SessionWallet\n}\n\nexport function Minter(props: MinterProps){\n    // Mint the chosen nft image with our minting account\n    const {cid} = useParams()\n    const [md, setMd] = React.useState(new Metadata({}))\n    const [importingAccount, setImportingAccount] = React.useState(undefined)\n    const [nft, setNFT] = React.useState(undefined)\n    const [fundLoading, setFundLoading] = React.useState(false)\n    const [loading, setLoading] = React.useState(false)\n    const [popupOpen,setPopupOpen] = React.useState(false)\n\n    const [createdId, setCreatedId] = React.useState(0)\n\n    React.useEffect(()=>{\n        if(md._raw === undefined)\n            getMetaFromIpfs(getIpfsUrlFromCID(props.activeConfig, cid)).then((md)=>{\n                setMd(md)\n            })\n    }, [props.activeConfig, cid, md])\n\n    async function mintOnly(){\n        // Create ASA with our user\n        setLoading(true)\n        const result = await NFT.create(props.sw.wallet, props.activeConfig,  md, cid)\n        setNFT(result)\n        setCreatedId(result.id())\n    }\n\n    async function handleScannedAccount(addr: string){\n        // Fires after successful scan of addr\n        await xferAsset(props.sw.wallet, props.activeConfig, addr, createdId)\n\n        setCreatedId(0)\n        setLoading(false)\n    }\n\n    async function mintAndCreate(){\n        // Create account\n        setLoading(true)\n        const acct = algosdk.generateAccount()\n        setImportingAccount(acct)\n    }\n\n    function cancelCreate() { \n        setLoading(false)\n        setImportingAccount(undefined) \n    }\n\n    async function continueCreate() {\n        // Create ASA\n        const result = await NFT.create(props.sw.wallet, props.activeConfig,  md, cid)\n        setNFT(result)\n        setPopupOpen(true)\n    }\n\n    async function fundIt(){\n        // User has scanned it, issue grouped transactions\n        setFundLoading(true)\n        \n        await fundAccount(props.sw.wallet, props.activeConfig, importingAccount, nft.id())\n        // Unset\n        setImportingAccount(undefined)\n        setFundLoading(false)\n        setLoading(false)\n        window.location.href=\"/NFTBooth\"\n    }\n\n    return (\n        <div className='container'>\n            <NFTCard loading={loading} cid={cid} md={md} mintOnly={mintOnly} mintAndCreate={mintAndCreate}></NFTCard>\n            <AccountImporter importingAccount={importingAccount} cancelCreate={cancelCreate} continueCreate={continueCreate}/>\n            <AddressReader  optIn={createdId} handleScanned={handleScannedAccount}></AddressReader>\n            <Dialog isOpen={popupOpen} >\n                <div className={DIALOG_BODY}>\n                    <div className='container'>\n                        <Button loading={fundLoading} intent='success' onClick={fundIt}>Fund it!</Button>\n                    </div>\n                </div>\n            </Dialog>\n        </div>\n    )\n}\n\ninterface NFTCardProps {\n    cid: string\n    md: Metadata\n    loading: boolean\n    mintOnly()\n    mintAndCreate()\n}\n\nfunction NFTCard(props: NFTCardProps) {\n    return (\n        <Card elevation={Elevation.THREE} >\n            <MediaDisplay \n                title={props.md.title()}\n                mediaSrc={resolveProtocol(0, props.md.mediaURL())} \n                mimeType={props.md.mimeType()} \n            />\n            <div className='container'>\n                <Button loading={props.loading} icon='clean' intent='success' onClick={props.mintAndCreate}>Mint</Button>\n            </div>\n        </Card>\n    )\n}\n\ninterface AccountImporterProps {\n    importingAccount: algosdk.Account \n    continueCreate()\n    cancelCreate()\n}\n\nfunction AccountImporter(props: AccountImporterProps) {\n    const [isOpen, setIsOpen] = React.useState(false)\n    const [mn, setMn]  = React.useState(\"\")\n\n    const ic = props.importingAccount\n    React.useEffect(()=>{\n        if(ic !== undefined){\n            setMn(JSON.stringify({\n                \"version\":\"1.0\", \n                \"mnemonic\":secretKeyToMnemonic(ic.sk)\n            }))\n            setIsOpen(true)\n        }\n    }, [ic])\n\n    function cancelCreate(){\n        setIsOpen(false)\n        props.cancelCreate()\n    }\n    function continueCreate(){\n        setIsOpen(false)\n        props.continueCreate()\n    }\n\n    return (\n        <Dialog isOpen={isOpen} className='content' >\n            <div className={DIALOG_BODY} >\n                <QRCode  value={mn} />\n            </div>\n            <div className={DIALOG_FOOTER} >\n                <div className='container'>\n                    <Button style={{margin:\"0px 10px\"}} intent='danger' onClick={cancelCreate}>Cancel</Button>\n                    <Button style={{margin:\"0px 10px\"}} intent='success' onClick={continueCreate}>Ready!</Button>\n                </div>\n            </div>\n        </Dialog>\n    )\n}\n\nexport interface AddressReaderProps {\n    optIn: number \n    handleScanned(addr: string): void\n}\n\nexport function AddressReader(props: AddressReaderProps) {\n    const vref = React.useRef<HTMLVideoElement>(null)\n    const [scanner, setScanner] = React.useState<QrScanner | undefined>(undefined)\n    const [isOpen, setIsOpen] = React.useState(false)\n\n    const open = props.optIn !== undefined && props.optIn>0\n    React.useEffect(()=>{\n        setIsOpen(open)\n        scanner?.stop()\n        scanner?.start()\n    }, [scanner, open])\n\n    let seen = \"\"\n    function initCam(){\n        function handleScanned(data: string){\n            if(seen === data) return\n\n            scanner?.stop()\n            vref.current = null\n            setScanner(undefined)\n            setIsOpen(false)\n            seen = data\n            props.handleScanned(data)\n        }\n\n        if(vref.current !== null && scanner === undefined)\n           setScanner(new QrScanner(vref.current,handleScanned))\n    }\n\n    return (\n        <Dialog isOpen={isOpen} onOpened={initCam}>\n            <div className={DIALOG_BODY}>\n                <h3>Please Opt into Asset ID {props.optIn}</h3>\n                <div className='scanner-container'>\n                    <video style={{width: '100%'}} ref={vref}></video>\n                </div>\n            </div>\n        </Dialog>\n    )\n}","import * as React from 'react'\n\nimport { SessionWallet, allowedWallets } from 'algorand-session-wallet'\n\nimport { Dialog, Button, Classes, HTMLSelect, Intent } from '@blueprintjs/core'\nimport { IconName } from '@blueprintjs/icons'\n\n\ntype AlgorandWalletConnectorProps = {\n    darkMode: boolean\n    connected: boolean\n    accts: string[]\n    sessionWallet: SessionWallet\n    updateWallet(sw: SessionWallet): void\n}\n\nexport default function AlgorandWalletConnector(props:AlgorandWalletConnectorProps)  {\n\n    const [selectorOpen, setSelectorOpen] = React.useState(false)\n\n    const {sessionWallet,updateWallet} = props\n    React.useEffect(()=>{\n        if(sessionWallet.connected()) return\n\n        let interval: any\n        sessionWallet.connect().then((success)=>{\n            if(!success) return\n\n            // Check every 500ms to see if we've connected then kill the interval\n            // This is most useful in the case of walletconnect where it may be several \n            // seconds before the user connects\n            interval = setInterval(()=>{\n                if(sessionWallet.connected()) {\n                    clearInterval(interval)\n                    updateWallet(sessionWallet)\n                }\n            }, 500)\n\n        })\n\n        return ()=>{ clearInterval(interval) }\n\n    }, [sessionWallet, updateWallet])\n\n\n    function disconnectWallet() { \n        props.sessionWallet.disconnect()\n        props.updateWallet(new SessionWallet(props.sessionWallet.network, props.sessionWallet.permissionCallback)) \n    }\n\n    function handleDisplayWalletSelection() { setSelectorOpen(true) }\n\n    async function handleSelectedWallet(e: any) {\n        const choice = e.currentTarget.id\n\n        if(!(choice in allowedWallets)) {\n            if(props.sessionWallet.wallet !== undefined) props.sessionWallet.disconnect()\n            return setSelectorOpen(false)\n        }\n\n        const sw = new SessionWallet(props.sessionWallet.network, props.sessionWallet.permissionCallback, choice)\n\n        if(!await sw.connect()) {\n            sw.disconnect()\n        }\n\n        props.updateWallet(sw)\n\n        setSelectorOpen(false)\n    }\n\n    function handleChangeAccount(e: any) {\n        props.sessionWallet.setAccountIndex(parseInt(e.target.value))\n        props.updateWallet(props.sessionWallet)\n    }\n\n    const walletOptions = []\n    for(const [k,v] of Object.entries(allowedWallets)){\n        walletOptions.push((\n        <li key={k}>\n            <Button id={k}\n                large={true} \n                fill={true} \n                minimal={true} \n                outlined={true} \n                onClick={handleSelectedWallet}\n                > \n                <div className='wallet-option'>\n                    <img alt='wallet-branding' className='wallet-branding' src={  v.img(props.darkMode)} />\n                    <h5>{v.displayName()}</h5>\n                </div>\n                </Button>\n        </li>\n        ))\n    }\n\n    if (!props.connected) return (\n        <div>\n            <Button\n                minimal={true}\n                rightIcon='selection'\n                intent='warning'\n                outlined={true}\n                onClick={handleDisplayWalletSelection}>Connect Wallet</Button>\n\n            <Dialog isOpen={selectorOpen} title='Select Wallet' onClose={handleSelectedWallet} >\n                <div className={Classes.DIALOG_BODY}>\n                    <ul className='wallet-option-list'>\n                        {walletOptions}\n                    </ul>\n                </div>\n            </Dialog>\n        </div>\n    )\n\n\n    const addr_list = props.accts.map((addr, idx) => {\n        return (<option value={idx} key={idx}> {addr.substr(0, 8)}...  </option>)\n    })\n\n    const iconprops = { \n        icon: 'symbol-circle' as IconName, \n        intent: 'success'  as Intent\n    }\n\n    return (\n        <div>\n            <HTMLSelect \n                onChange={handleChangeAccount} \n                minimal={true} \n                iconProps={iconprops} \n                defaultValue={props.sessionWallet.accountIndex()} >\n                {addr_list}\n            </HTMLSelect>\n            <Button icon='log-out' minimal={true} onClick={disconnectWallet} ></Button>\n        </div>\n    )\n}","import Picker from './Picker'\nimport './index.css';\nimport { Button, Alignment, Navbar } from '@blueprintjs/core';\nimport { SessionWallet } from 'algorand-session-wallet';\nimport {Uploader} from './Uploader'\nimport React from 'react';\nimport {Minter} from './Minter';\nimport AlgorandWalletConnector from './AlgorandWalletConnector'\nimport { conf, sessionGetActiveConf } from './lib/config';\n\nimport {\n  HashRouter as Router,\n  Link,\n  Switch,\n  Route,\n} from 'react-router-dom'\n\n\ntype AppProps = {\n  history: History,\n}\n\nfunction App(props: AppProps) {\n\n  const activeConf = sessionGetActiveConf()\n\n  const sw = new SessionWallet(conf[activeConf].network)\n\n\n  const [sessionWallet, setSessionWallet] =  React.useState(sw)\n  const [accts, setAccounts] = React.useState(sw.accountList())\n  const [connected, setConnected] = React.useState(sw.connected())\n\n  function updateWallet(sw: SessionWallet){ \n    setSessionWallet(sw)\n    setAccounts(sw.accountList())\n    setConnected(sw.connected())\n  }\n\n  return (\n    <Router >\n      <div className=\"App\">\n        <Navbar>\n        <Navbar.Group align={Alignment.LEFT}>\n          <Navbar.Heading>Algorand NFT Minter</Navbar.Heading>\n          <Navbar.Divider />\n          <Link to='/'><Button minimal={true} icon='search'>Choose</Button></Link>\n          <Link to='/upload'><Button minimal={true} icon='upload'>Upload</Button></Link>\n        </Navbar.Group>\n        <Navbar.Group  align={Alignment.RIGHT}>\n          <AlgorandWalletConnector  \n            darkMode={false}\n            sessionWallet={sessionWallet}\n            accts={accts}\n            connected={connected} \n            updateWallet={updateWallet}\n          />\n\n        </Navbar.Group>\n        </Navbar>\n        <Switch>\n          <Route exact path=\"/\" children={<Picker  activeConfig={activeConf} sw={sessionWallet}></Picker>} />\n          <Route path=\"/mint/:cid\" children={ <Minter  activeConfig={activeConf} sw={sessionWallet}></Minter> }/>\n          <Route exact path=\"/upload\" children={ <Uploader  activeConfig={activeConf} ></Uploader> }/>\n        </Switch>\n      </div>\n    </Router>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\n\n\nimport {createBrowserHistory} from \"history\"\n\nconst history = createBrowserHistory();\n\nReactDOM.render(\n  <React.StrictMode>\n    <App history={history}  />\n  </React.StrictMode>,\n  document.getElementById('root')\n);","import { ipfsURL, mediaIntegrity } from './nft'\nimport {Metadata} from './metadata'\nimport {conf} from './config'\n\n/*\n Currently an issue with resolving ipfs-car module in web3.storage when using react-scripts\n We just use the prebuilt one but with no types we have to just ignore the issue for now\n//import { Web3Storage } from 'web3.storage'\n*/\n// @ts-ignore\nimport { Web3Storage } from 'web3.storage/dist/bundle.esm.min.js'\n\n\nlet storageClient = undefined\nfunction getStorageClient(activeConf: number): Web3Storage {\n    if(storageClient === undefined){\n        storageClient = new Web3Storage({ token: \" \", endpoint:\"https://worker.barnji.workers.dev\" })\n    }\n    return storageClient\n}\n\nexport async function putToIPFS(activeConf: number, file: File, md: Metadata): Promise<string> {\n    const storage = getStorageClient(activeConf) \n    const mediaAdded = await storage.put([file], {wrapWithDirectory: false})\n\n    const integ = await mediaIntegrity(file)\n\n    const mdc = {...md}\n    switch(md.mediaType()){\n        case 'image':\n            mdc.image = ipfsURL(mediaAdded)\n            mdc.image_integrity = integ\n            break\n        case 'audio':\n            mdc.animation_url = ipfsURL(mediaAdded)\n            mdc.animation_url_integrity = integ\n            break\n        case 'video':\n            mdc.animation_url = ipfsURL(mediaAdded)\n            mdc.animation_url_integrity = integ\n            break\n    }\n\n    const mdobj = new Metadata(mdc)\n\n    return await storage.put([mdobj.toFile()], {wrapWithDirectory: false})\n}\n\nexport async function listRecentFiles( activeConf: number, ms_threshold: number): Promise<any[]> {\n    const w3s = getStorageClient(activeConf)\n    const options = []\n    for await (const upload of w3s.list({maxResults:10})) {\n        options.push(upload)\n    }\n    return options\n}\n\nexport function getIpfsUrlFromCID(activeConf:number, cid: string): string {\n    return conf[activeConf].ipfsGateway + cid\n}\n\nexport async function getMimeTypeFromIpfs(url: string): Promise<string> {\n    const req = new Request(url, { method:\"HEAD\" })\n    const resp = await fetch(req)\n    return resp.headers.get(\"Content-Type\")\n}\n\n\nexport async function getMetaFromIpfs(url: string): Promise<Metadata> {\n    try {\n        const req = new Request(url)\n        const resp = await fetch(req)\n        const body = await resp.blob()\n        const text = await body.text()\n        const parsed = JSON.parse(text)\n        return new Metadata({\"_raw\":text, ...parsed}) \n    } catch (e){\n        console.error(e)\n    }\n\n    return new Metadata({})\n}","type Config = {\n    network: string;       // The network to use for creating nfts\n    storageToken: string;  // The token provided by web3.storage\n    ipfsGateway: string;   // The IPFS gateway url for retrieving files\n    algod: string          // The Algod api url to use\n    blockExplorer: string; // The Block Explorer to allow linking out to\n}\n\nexport const conf = require(\"../config.json\") as Config[];\n\nexport function getAddrUrl(idx: number, addr: string): string {\n    return conf[idx].blockExplorer + \"address/\" + addr\n}\nexport function getAsaUrl(idx: number, id: number): string {\n    return conf[idx].blockExplorer + \"asset/\" + id \n}\n\nconst activeConfKey = \"active-conf\"\nexport function sessionGetActiveConf(): number {\n    const ac = sessionStorage.getItem(activeConfKey)\n    if(ac === undefined || ac === null) return 0\n    return parseInt(ac)\n}\n\nexport function sessionSetActiveConf(ac: number)  {\n    sessionStorage.setItem(activeConfKey, ac.toString())\n}\n","import { Wallet } from \"algorand-session-wallet\";\nimport algosdk, {\n  Algodv2,\n  waitForConfirmation,\n  makeAssetCreateTxnWithSuggestedParamsFromObject,\n  makeAssetTransferTxnWithSuggestedParamsFromObject,\n  makePaymentTxnWithSuggestedParamsFromObject,\n} from \"algosdk\";\nimport { NFT } from \"./nft\";\nimport { Metadata } from \"./metadata\";\nimport { conf } from \"./config\";\n\nfunction getClient(activeConf: number): Algodv2 {\n  return new algosdk.Algodv2(\"\", conf[activeConf].algod, \"\");\n}\n\nexport async function createToken(\n  wallet: Wallet,\n  activeConf: number,\n  url: string,\n  md: Metadata\n): Promise<number> {\n  const addr = wallet.getDefaultAccount();\n  const suggested = await getSuggested(activeConf, 1000);\n\n  const create_txn = makeAssetCreateTxnWithSuggestedParamsFromObject({\n    from: addr,\n    assetName: md.name,\n    unitName: md.unitName,\n    assetURL: url,\n    assetMetadataHash: md.toHash(),\n    manager: addr,\n    total: 1,\n    decimals: 0,\n    defaultFrozen: false,\n    suggestedParams: suggested,\n  });\n\n  const [create_txn_s]  = await wallet.signTxn([create_txn])\n  const result = await sendWait(activeConf, [create_txn_s])\n  return result['asset-index']\n}\n\nexport async function fundAccount(\n  wallet: Wallet,\n  activeConf: number,\n  acct: algosdk.Account,\n  id: number\n) {\n  const addr = wallet.getDefaultAccount();\n  const suggested = await getSuggested(activeConf, 100);\n\n  const fund_txn = makePaymentTxnWithSuggestedParamsFromObject({\n    from: addr,\n    to: acct.addr,\n    amount: 3e5,\n    suggestedParams: suggested,\n  });\n\n  const optin_txn = makeAssetTransferTxnWithSuggestedParamsFromObject({\n    from: acct.addr,\n    to: acct.addr,\n    assetIndex: id,\n    amount: 0,\n    suggestedParams: suggested,\n  });\n\n  const xfer_txn = makeAssetTransferTxnWithSuggestedParamsFromObject({\n    from: addr,\n    to: acct.addr,\n    assetIndex: id,\n    amount: 1,\n    suggestedParams: suggested,\n  });\n\n\n  const grouped = [fund_txn, optin_txn, xfer_txn];\n  algosdk.assignGroupID(grouped);\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  const [fund_txn_s, _, xfer_txn_s] = await wallet.signTxn(grouped);\n  const optin_txn_s = algosdk.signTransaction(optin_txn, acct.sk);\n  await sendWait(activeConf, [fund_txn_s, optin_txn_s, xfer_txn_s]);\n}\n\nexport async function xferAsset(\n  wallet: Wallet,\n  activeConf: number,\n  rx: string,\n  id: number\n) {\n  const addr = wallet.getDefaultAccount();\n  const suggested = await getSuggested(activeConf, 100);\n\n  const xfer_txn = makeAssetTransferTxnWithSuggestedParamsFromObject({\n    from: addr,\n    to: rx,\n    assetIndex: id,\n    amount: 1,\n    suggestedParams: suggested,\n  });\n\n  const [create_txn_s] = await wallet.signTxn([xfer_txn]);\n  await sendWait(activeConf, [create_txn_s]);\n}\n\nexport async function getSuggested(activeConf: number, rounds: number) {\n  const txParams = await getClient(activeConf).getTransactionParams().do();\n  return { ...txParams, lastRound: txParams[\"firstRound\"] + rounds };\n}\n\nexport async function getToken(\n  activeConf: number,\n  assetId: number\n): Promise<any> {\n  return await getClient(activeConf).getAssetByID(assetId).do();\n}\n\nexport async function getCollection(\n  activeConf: number,\n  address: string\n): Promise<any[]> {\n  const results = await getClient(activeConf).accountInformation(address).do();\n\n  const plist = [];\n  for (const a in results[\"assets\"]) {\n    if (results[\"assets\"][a][\"amount\"] > 0)\n      plist.push(getToken(activeConf, results[\"assets\"][a][\"asset-id\"]));\n  }\n\n  const assets = await Promise.all(plist);\n  const collectionRequests = assets.map((a) => {\n    return NFT.fromToken(activeConf, a);\n  });\n  return Promise.all(collectionRequests);\n}\n\nexport async function sendWait(\n  activeConf: number,\n  signed: any[]\n): Promise<any> {\n  const client = getClient(activeConf);\n  try {\n    const { txId } = await client\n      .sendRawTransaction( signed.map((t) => { return t.blob; }))\n      .do();\n    const result = await waitForConfirmation(client, txId, 3);\n    return result;\n  } catch (error) {\n    console.error(error);\n  }\n\n  return undefined;\n}"],"sourceRoot":""}